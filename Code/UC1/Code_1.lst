CCS PCM C Compiler, Version 5.015, 5967               03-oct.-21 01:16

               Filename:   D:\arc\UNIVERSIDAD\Unicauca\6to Semestre\Circuitos Digitales II\FinalBusinessModel\Code\Code_1.lst

               ROM used:   3269 words (40%)
                           Largest free fragment is 2048
               RAM used:   54 (15%) at main() level
                           81 (22%) worst case
               Stack used: 7 locations (6 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   2A8
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BSF    03.6
0016:  MOVF   0D,W
0017:  BCF    03.6
0018:  MOVWF  27
0019:  BSF    03.6
001A:  MOVF   0F,W
001B:  BCF    03.6
001C:  MOVWF  28
001D:  BSF    03.6
001E:  MOVF   0C,W
001F:  BCF    03.6
0020:  MOVWF  29
0021:  BSF    03.6
0022:  MOVF   0E,W
0023:  BCF    03.6
0024:  MOVWF  2A
0025:  BCF    03.7
0026:  BCF    03.5
0027:  MOVLW  8C
0028:  MOVWF  04
0029:  BTFSS  00.5
002A:  GOTO   02D
002B:  BTFSC  0C.5
002C:  GOTO   04E
002D:  MOVF   22,W
002E:  MOVWF  04
002F:  MOVF   23,W
0030:  MOVWF  77
0031:  MOVF   24,W
0032:  MOVWF  78
0033:  MOVF   25,W
0034:  MOVWF  79
0035:  MOVF   26,W
0036:  MOVWF  7A
0037:  MOVF   27,W
0038:  BSF    03.6
0039:  MOVWF  0D
003A:  BCF    03.6
003B:  MOVF   28,W
003C:  BSF    03.6
003D:  MOVWF  0F
003E:  BCF    03.6
003F:  MOVF   29,W
0040:  BSF    03.6
0041:  MOVWF  0C
0042:  BCF    03.6
0043:  MOVF   2A,W
0044:  BSF    03.6
0045:  MOVWF  0E
0046:  BCF    03.6
0047:  MOVF   20,W
0048:  MOVWF  0A
0049:  SWAPF  21,W
004A:  MOVWF  03
004B:  SWAPF  7F,F
004C:  SWAPF  7F,W
004D:  RETFIE
004E:  BCF    0A.3
004F:  BCF    0A.4
0050:  GOTO   061
.................... #include <16f887.h> 
.................... //////////// Standard Header file for the PIC16F887 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC16F887 
0051:  BCF    0A.0
0052:  BCF    0A.1
0053:  BCF    0A.2
0054:  ADDWF  02,F
0055:  RETLW  31
0056:  RETLW  32
0057:  RETLW  33
0058:  RETLW  34
0059:  RETLW  35
005A:  RETLW  36
005B:  RETLW  37
005C:  RETLW  38
005D:  RETLW  39
005E:  RETLW  2A
005F:  RETLW  30
0060:  RETLW  23
*
006B:  DATA 0C,00
006C:  DATA 43,26
006D:  DATA 41,2B
006E:  DATA 45,10
006F:  DATA C1,21
0070:  DATA D4,2A
0071:  DATA 41,26
0072:  DATA 00,01
0073:  DATA 0C,00
0074:  DATA 43,26
0075:  DATA 41,2B
0076:  DATA 45,10
0077:  DATA CE,2A
0078:  DATA 45,2B
0079:  DATA 41,10
007A:  DATA 20,00
007B:  DATA 0C,00
007C:  DATA A0,21
007D:  DATA CC,20
007E:  DATA D6,22
007F:  DATA A0,24
0080:  DATA 4E,2B
0081:  DATA 41,26
0082:  DATA 49,22
0083:  DATA 41,10
0084:  DATA 00,01
0085:  DATA 0C,00
0086:  DATA 0C,00
0087:  DATA 20,22
0088:  DATA C9,23
0089:  DATA 49,2A
008A:  DATA 45,10
008B:  DATA 43,26
008C:  DATA 41,2B
008D:  DATA 45,10
008E:  DATA 00,01
008F:  DATA 0C,00
0090:  DATA A0,21
0091:  DATA CC,20
0092:  DATA D6,22
0093:  DATA A0,21
0094:  DATA 4F,29
0095:  DATA D2,22
0096:  DATA 43,2A
0097:  DATA 41,10
0098:  DATA 00,01
0099:  DATA 0C,00
009A:  DATA A0,24
009B:  DATA CE,23
009C:  DATA D2,22
009D:  DATA D3,22
009E:  DATA A0,29
009F:  DATA 55,10
00A0:  DATA 4F,28
00A1:  DATA 43,10
00A2:  DATA 00,01
00A3:  DATA 0C,00
00A4:  DATA A0,27
00A5:  DATA D0,21
00A6:  DATA C9,27
00A7:  DATA 4E,10
00A8:  DATA 31,10
00A9:  DATA 00,01
00AA:  DATA 0C,00
00AB:  DATA 0C,2A
00AC:  DATA C5,26
00AD:  DATA D0,22
00AE:  DATA D2,20
00AF:  DATA D4,2A
00B0:  DATA D2,20
00B1:  DATA 00,01
00B2:  DATA C3,1E
00B3:  DATA A0,12
00B4:  DATA 66,10
00B5:  DATA 20,10
00B6:  DATA 20,00
00B7:  DATA 0C,00
00B8:  DATA 0C,2A
00B9:  DATA C5,26
00BA:  DATA D0,22
00BB:  DATA D2,20
00BC:  DATA D4,2A
00BD:  DATA D2,20
00BE:  DATA 00,01
00BF:  DATA C3,1E
00C0:  DATA A0,12
00C1:  DATA 66,10
00C2:  DATA 20,10
00C3:  DATA 20,00
00C4:  DATA 0C,00
00C5:  DATA 0C,00
00C6:  DATA A0,21
00C7:  DATA CC,20
00C8:  DATA D6,22
00C9:  DATA A0,24
00CA:  DATA 4E,2B
00CB:  DATA 41,26
00CC:  DATA 49,22
00CD:  DATA 41,10
00CE:  DATA 00,00
*
0177:  MOVLW  10
0178:  MOVWF  6B
0179:  CLRF   77
017A:  CLRF   7A
017B:  RRF    68,F
017C:  RRF    67,F
017D:  BTFSS  03.0
017E:  GOTO   185
017F:  MOVF   69,W
0180:  ADDWF  77,F
0181:  BTFSC  03.0
0182:  INCF   7A,F
0183:  MOVF   6A,W
0184:  ADDWF  7A,F
0185:  RRF    7A,F
0186:  RRF    77,F
0187:  RRF    79,F
0188:  RRF    78,F
0189:  DECFSZ 6B,F
018A:  GOTO   17B
018B:  RETURN
018C:  CLRF   77
018D:  CLRF   78
018E:  MOVF   65,W
018F:  BCF    03.0
0190:  BTFSC  66.0
0191:  ADDWF  77,F
0192:  RRF    77,F
0193:  RRF    78,F
0194:  BTFSC  66.1
0195:  ADDWF  77,F
0196:  RRF    77,F
0197:  RRF    78,F
0198:  BTFSC  66.2
0199:  ADDWF  77,F
019A:  RRF    77,F
019B:  RRF    78,F
019C:  BTFSC  66.3
019D:  ADDWF  77,F
019E:  RRF    77,F
019F:  RRF    78,F
01A0:  BTFSC  66.4
01A1:  ADDWF  77,F
01A2:  RRF    77,F
01A3:  RRF    78,F
01A4:  BTFSC  66.5
01A5:  ADDWF  77,F
01A6:  RRF    77,F
01A7:  RRF    78,F
01A8:  BTFSC  66.6
01A9:  ADDWF  77,F
01AA:  RRF    77,F
01AB:  RRF    78,F
01AC:  BTFSC  66.7
01AD:  ADDWF  77,F
01AE:  RRF    77,F
01AF:  RRF    78,F
01B0:  RETURN
*
01EF:  MOVF   0B,W
01F0:  MOVWF  5B
01F1:  BCF    0B.7
01F2:  BSF    03.5
01F3:  BSF    03.6
01F4:  BSF    0C.7
01F5:  BSF    0C.0
01F6:  NOP
01F7:  NOP
01F8:  BCF    03.5
01F9:  BCF    03.6
01FA:  BTFSC  5B.7
01FB:  BSF    0B.7
01FC:  BSF    03.6
01FD:  MOVF   0C,W
01FE:  ANDLW  7F
01FF:  BTFSC  03.2
0200:  GOTO   243
0201:  BCF    03.6
0202:  MOVWF  5B
0203:  BSF    03.6
0204:  MOVF   0D,W
0205:  BCF    03.6
0206:  MOVWF  5C
0207:  BSF    03.6
0208:  MOVF   0F,W
0209:  BCF    03.6
020A:  MOVWF  5D
020B:  MOVF   5B,W
020C:  MOVWF  5E
020D:  CALL   1C3
020E:  MOVF   5C,W
020F:  BSF    03.6
0210:  MOVWF  0D
0211:  BCF    03.6
0212:  MOVF   5D,W
0213:  BSF    03.6
0214:  MOVWF  0F
0215:  BCF    03.6
0216:  MOVF   0B,W
0217:  MOVWF  5E
0218:  BCF    0B.7
0219:  BSF    03.5
021A:  BSF    03.6
021B:  BSF    0C.7
021C:  BSF    0C.0
021D:  NOP
021E:  NOP
021F:  BCF    03.5
0220:  BCF    03.6
0221:  BTFSC  5E.7
0222:  BSF    0B.7
0223:  BSF    03.6
0224:  RLF    0C,W
0225:  RLF    0E,W
0226:  ANDLW  7F
0227:  BTFSC  03.2
0228:  GOTO   243
0229:  BCF    03.6
022A:  MOVWF  5B
022B:  BSF    03.6
022C:  MOVF   0D,W
022D:  BCF    03.6
022E:  MOVWF  5C
022F:  BSF    03.6
0230:  MOVF   0F,W
0231:  BCF    03.6
0232:  MOVWF  5D
0233:  MOVF   5B,W
0234:  MOVWF  5E
0235:  CALL   1C3
0236:  MOVF   5C,W
0237:  BSF    03.6
0238:  MOVWF  0D
0239:  BCF    03.6
023A:  MOVF   5D,W
023B:  BSF    03.6
023C:  MOVWF  0F
023D:  INCF   0D,F
023E:  BTFSC  03.2
023F:  INCF   0F,F
0240:  BCF    03.6
0241:  GOTO   1EF
0242:  BSF    03.6
0243:  BCF    03.6
0244:  RETURN
*
04F3:  MOVF   57,W
04F4:  CLRF   78
04F5:  SUBWF  56,W
04F6:  BTFSC  03.0
04F7:  GOTO   4FB
04F8:  MOVF   56,W
04F9:  MOVWF  77
04FA:  GOTO   507
04FB:  CLRF   77
04FC:  MOVLW  08
04FD:  MOVWF  58
04FE:  RLF    56,F
04FF:  RLF    77,F
0500:  MOVF   57,W
0501:  SUBWF  77,W
0502:  BTFSC  03.0
0503:  MOVWF  77
0504:  RLF    78,F
0505:  DECFSZ 58,F
0506:  GOTO   4FE
0507:  RETURN
0508:  MOVLW  20
0509:  BTFSS  51.4
050A:  MOVLW  30
050B:  MOVWF  52
050C:  MOVF   50,W
050D:  MOVWF  77
050E:  BTFSS  50.7
050F:  GOTO   518
0510:  COMF   77,F
0511:  INCF   77,F
0512:  MOVF   77,W
0513:  MOVWF  50
0514:  MOVLW  2D
0515:  MOVWF  52
0516:  BSF    51.7
0517:  BSF    51.0
0518:  MOVF   50,W
0519:  MOVWF  56
051A:  MOVLW  64
051B:  MOVWF  57
051C:  CALL   4F3
051D:  MOVF   77,W
051E:  MOVWF  50
051F:  MOVLW  30
0520:  ADDWF  78,W
0521:  MOVWF  53
0522:  MOVF   50,W
0523:  MOVWF  56
0524:  MOVLW  0A
0525:  MOVWF  57
0526:  CALL   4F3
0527:  MOVLW  30
0528:  ADDWF  77,W
0529:  MOVWF  55
052A:  MOVLW  30
052B:  ADDWF  78,W
052C:  MOVWF  54
052D:  MOVF   52,W
052E:  MOVWF  77
052F:  MOVLW  30
0530:  SUBWF  53,W
0531:  BTFSC  03.2
0532:  GOTO   537
0533:  BSF    51.1
0534:  BTFSC  51.7
0535:  BSF    51.2
0536:  GOTO   54B
0537:  MOVF   52,W
0538:  MOVWF  53
0539:  MOVLW  20
053A:  MOVWF  52
053B:  MOVLW  30
053C:  SUBWF  54,W
053D:  BTFSC  03.2
053E:  GOTO   543
053F:  BSF    51.0
0540:  BTFSC  51.7
0541:  BSF    51.1
0542:  GOTO   54B
0543:  BTFSS  03.2
0544:  BSF    51.0
0545:  BTFSS  03.2
0546:  GOTO   54B
0547:  MOVF   53,W
0548:  MOVWF  54
0549:  MOVLW  20
054A:  MOVWF  53
054B:  BTFSC  51.2
054C:  GOTO   552
054D:  BTFSC  51.1
054E:  GOTO   555
054F:  BTFSC  51.0
0550:  GOTO   558
0551:  GOTO   55B
0552:  MOVF   52,W
0553:  MOVWF  5E
0554:  CALL   1C3
0555:  MOVF   53,W
0556:  MOVWF  5E
0557:  CALL   1C3
0558:  MOVF   54,W
0559:  MOVWF  5E
055A:  CALL   1C3
055B:  MOVF   55,W
055C:  MOVWF  5E
055D:  CALL   1C3
055E:  BSF    0A.3
055F:  BCF    0A.4
0560:  GOTO   40B (RETURN)
0561:  MOVLW  8E
0562:  MOVWF  77
0563:  MOVF   52,W
0564:  MOVWF  78
0565:  MOVF   51,W
0566:  MOVWF  79
0567:  CLRF   7A
0568:  MOVF   78,F
0569:  BTFSS  03.2
056A:  GOTO   575
056B:  MOVF   79,W
056C:  MOVWF  78
056D:  CLRF   79
056E:  MOVLW  08
056F:  SUBWF  77,F
0570:  MOVF   78,F
0571:  BTFSS  03.2
0572:  GOTO   575
0573:  CLRF   77
0574:  GOTO   57D
0575:  BCF    03.0
0576:  BTFSC  78.7
0577:  GOTO   57C
0578:  RLF    79,F
0579:  RLF    78,F
057A:  DECF   77,F
057B:  GOTO   575
057C:  BCF    78.7
057D:  RETURN
057E:  MOVF   5D,W
057F:  BTFSC  03.2
0580:  GOTO   5EE
0581:  MOVWF  65
0582:  MOVF   61,W
0583:  BTFSC  03.2
0584:  GOTO   5EE
0585:  ADDWF  65,F
0586:  BTFSC  03.0
0587:  GOTO   58F
0588:  MOVLW  7F
0589:  SUBWF  65,F
058A:  BTFSS  03.0
058B:  GOTO   5EE
058C:  BTFSC  03.2
058D:  GOTO   5EE
058E:  GOTO   593
058F:  MOVLW  81
0590:  ADDWF  65,F
0591:  BTFSC  03.0
0592:  GOTO   5EE
0593:  MOVF   65,W
0594:  MOVWF  77
0595:  CLRF   78
0596:  CLRF   79
0597:  CLRF   7A
0598:  MOVF   5E,W
0599:  MOVWF  69
059A:  BSF    69.7
059B:  MOVF   5F,W
059C:  MOVWF  68
059D:  MOVF   60,W
059E:  MOVWF  67
059F:  MOVLW  18
05A0:  MOVWF  65
05A1:  CLRF   66
05A2:  BTFSS  67.0
05A3:  GOTO   5BC
05A4:  MOVF   64,W
05A5:  ADDWF  7A,F
05A6:  BTFSS  03.0
05A7:  GOTO   5AE
05A8:  INCF   79,F
05A9:  BTFSS  03.2
05AA:  GOTO   5AE
05AB:  INCF   78,F
05AC:  BTFSC  03.2
05AD:  BSF    66.7
05AE:  MOVF   63,W
05AF:  ADDWF  79,F
05B0:  BTFSS  03.0
05B1:  GOTO   5B5
05B2:  INCF   78,F
05B3:  BTFSC  03.2
05B4:  BSF    66.7
05B5:  MOVF   62,W
05B6:  MOVWF  5F
05B7:  BSF    5F.7
05B8:  MOVF   5F,W
05B9:  ADDWF  78,F
05BA:  BTFSC  03.0
05BB:  BSF    66.7
05BC:  RLF    66,F
05BD:  RRF    78,F
05BE:  RRF    79,F
05BF:  RRF    7A,F
05C0:  RRF    69,F
05C1:  RRF    68,F
05C2:  RRF    67,F
05C3:  BCF    03.0
05C4:  DECFSZ 65,F
05C5:  GOTO   5A1
05C6:  MOVLW  01
05C7:  ADDWF  77,F
05C8:  BTFSC  03.0
05C9:  GOTO   5EE
05CA:  BTFSC  78.7
05CB:  GOTO   5D3
05CC:  RLF    69,F
05CD:  RLF    7A,F
05CE:  RLF    79,F
05CF:  RLF    78,F
05D0:  DECF   77,F
05D1:  BTFSC  03.2
05D2:  GOTO   5EE
05D3:  BTFSS  69.7
05D4:  GOTO   5E4
05D5:  INCF   7A,F
05D6:  BTFSS  03.2
05D7:  GOTO   5E4
05D8:  INCF   79,F
05D9:  BTFSS  03.2
05DA:  GOTO   5E4
05DB:  INCF   78,F
05DC:  BTFSS  03.2
05DD:  GOTO   5E4
05DE:  RRF    78,F
05DF:  RRF    79,F
05E0:  RRF    7A,F
05E1:  INCF   77,F
05E2:  BTFSC  03.2
05E3:  GOTO   5EE
05E4:  MOVF   5E,W
05E5:  MOVWF  66
05E6:  MOVF   62,W
05E7:  XORWF  66,F
05E8:  BTFSS  66.7
05E9:  GOTO   5EC
05EA:  BSF    78.7
05EB:  GOTO   5F2
05EC:  BCF    78.7
05ED:  GOTO   5F2
05EE:  CLRF   77
05EF:  CLRF   78
05F0:  CLRF   79
05F1:  CLRF   7A
05F2:  RETURN
05F3:  BTFSC  03.1
05F4:  GOTO   5F8
05F5:  MOVLW  65
05F6:  MOVWF  04
05F7:  BCF    03.7
05F8:  CLRF   77
05F9:  CLRF   78
05FA:  CLRF   79
05FB:  CLRF   7A
05FC:  CLRF   65
05FD:  CLRF   66
05FE:  CLRF   67
05FF:  CLRF   68
0600:  MOVF   64,W
0601:  IORWF  63,W
0602:  IORWF  62,W
0603:  IORWF  61,W
0604:  BTFSC  03.2
0605:  GOTO   636
0606:  MOVLW  20
0607:  MOVWF  69
0608:  BCF    03.0
0609:  RLF    5D,F
060A:  RLF    5E,F
060B:  RLF    5F,F
060C:  RLF    60,F
060D:  RLF    65,F
060E:  RLF    66,F
060F:  RLF    67,F
0610:  RLF    68,F
0611:  MOVF   64,W
0612:  SUBWF  68,W
0613:  BTFSS  03.2
0614:  GOTO   61F
0615:  MOVF   63,W
0616:  SUBWF  67,W
0617:  BTFSS  03.2
0618:  GOTO   61F
0619:  MOVF   62,W
061A:  SUBWF  66,W
061B:  BTFSS  03.2
061C:  GOTO   61F
061D:  MOVF   61,W
061E:  SUBWF  65,W
061F:  BTFSS  03.0
0620:  GOTO   630
0621:  MOVF   61,W
0622:  SUBWF  65,F
0623:  MOVF   62,W
0624:  BTFSS  03.0
0625:  INCFSZ 62,W
0626:  SUBWF  66,F
0627:  MOVF   63,W
0628:  BTFSS  03.0
0629:  INCFSZ 63,W
062A:  SUBWF  67,F
062B:  MOVF   64,W
062C:  BTFSS  03.0
062D:  INCFSZ 64,W
062E:  SUBWF  68,F
062F:  BSF    03.0
0630:  RLF    77,F
0631:  RLF    78,F
0632:  RLF    79,F
0633:  RLF    7A,F
0634:  DECFSZ 69,F
0635:  GOTO   608
0636:  MOVF   65,W
0637:  MOVWF  00
0638:  INCF   04,F
0639:  MOVF   66,W
063A:  MOVWF  00
063B:  INCF   04,F
063C:  MOVF   67,W
063D:  MOVWF  00
063E:  INCF   04,F
063F:  MOVF   68,W
0640:  MOVWF  00
0641:  RETURN
0642:  MOVF   04,W
0643:  MOVWF  55
0644:  MOVF   54,W
0645:  MOVWF  57
0646:  BTFSC  03.2
0647:  GOTO   661
0648:  MOVF   53,W
0649:  MOVWF  60
064A:  MOVF   52,W
064B:  MOVWF  5F
064C:  MOVF   51,W
064D:  MOVWF  5E
064E:  MOVF   50,W
064F:  MOVWF  5D
0650:  CLRF   64
0651:  CLRF   63
0652:  MOVLW  20
0653:  MOVWF  62
0654:  MOVLW  82
0655:  MOVWF  61
0656:  CALL   57E
0657:  MOVF   7A,W
0658:  MOVWF  53
0659:  MOVF   79,W
065A:  MOVWF  52
065B:  MOVF   78,W
065C:  MOVWF  51
065D:  MOVF   77,W
065E:  MOVWF  50
065F:  DECFSZ 57,F
0660:  GOTO   648
0661:  MOVF   53,W
0662:  MOVWF  60
0663:  MOVF   52,W
0664:  MOVWF  5F
0665:  MOVF   51,W
0666:  MOVWF  5E
0667:  MOVF   50,W
0668:  MOVWF  5D
0669:  MOVF   5D,W
066A:  SUBLW  B6
066B:  MOVWF  5D
066C:  CLRF   7A
066D:  MOVF   5E,W
066E:  MOVWF  61
066F:  BSF    5E.7
0670:  BCF    03.0
0671:  RRF    5E,F
0672:  RRF    5F,F
0673:  RRF    60,F
0674:  RRF    7A,F
0675:  RRF    79,F
0676:  RRF    78,F
0677:  RRF    77,F
0678:  DECFSZ 5D,F
0679:  GOTO   670
067A:  BTFSS  61.7
067B:  GOTO   687
067C:  COMF   77,F
067D:  COMF   78,F
067E:  COMF   79,F
067F:  COMF   7A,F
0680:  INCF   77,F
0681:  BTFSC  03.2
0682:  INCF   78,F
0683:  BTFSC  03.2
0684:  INCF   79,F
0685:  BTFSC  03.2
0686:  INCF   7A,F
0687:  MOVF   7A,W
0688:  MOVWF  53
0689:  MOVF   79,W
068A:  MOVWF  52
068B:  MOVF   78,W
068C:  MOVWF  51
068D:  MOVF   77,W
068E:  MOVWF  50
068F:  BTFSS  53.7
0690:  GOTO   69E
0691:  DECF   55,F
0692:  BSF    55.5
0693:  COMF   50,F
0694:  COMF   51,F
0695:  COMF   52,F
0696:  COMF   53,F
0697:  INCF   50,F
0698:  BTFSC  03.2
0699:  INCF   51,F
069A:  BTFSC  03.2
069B:  INCF   52,F
069C:  BTFSC  03.2
069D:  INCF   53,F
069E:  MOVLW  3B
069F:  MOVWF  5C
06A0:  MOVLW  9A
06A1:  MOVWF  5B
06A2:  MOVLW  CA
06A3:  MOVWF  5A
06A4:  CLRF   59
06A5:  MOVLW  0A
06A6:  MOVWF  57
06A7:  MOVF   54,W
06A8:  BTFSC  03.2
06A9:  INCF   55,F
06AA:  BSF    03.1
06AB:  MOVLW  50
06AC:  MOVWF  04
06AD:  BCF    03.7
06AE:  MOVF   53,W
06AF:  MOVWF  60
06B0:  MOVF   52,W
06B1:  MOVWF  5F
06B2:  MOVF   51,W
06B3:  MOVWF  5E
06B4:  MOVF   50,W
06B5:  MOVWF  5D
06B6:  MOVF   5C,W
06B7:  MOVWF  64
06B8:  MOVF   5B,W
06B9:  MOVWF  63
06BA:  MOVF   5A,W
06BB:  MOVWF  62
06BC:  MOVF   59,W
06BD:  MOVWF  61
06BE:  CALL   5F3
06BF:  MOVF   78,W
06C0:  MOVF   77,F
06C1:  BTFSS  03.2
06C2:  GOTO   6D6
06C3:  INCF   54,W
06C4:  SUBWF  57,W
06C5:  BTFSC  03.2
06C6:  GOTO   6D6
06C7:  MOVF   55,W
06C8:  BTFSC  03.2
06C9:  GOTO   6D8
06CA:  ANDLW  0F
06CB:  SUBWF  57,W
06CC:  BTFSC  03.2
06CD:  GOTO   6D0
06CE:  BTFSC  03.0
06CF:  GOTO   708
06D0:  BTFSC  55.7
06D1:  GOTO   708
06D2:  BTFSC  55.6
06D3:  GOTO   6D8
06D4:  MOVLW  20
06D5:  GOTO   704
06D6:  MOVLW  20
06D7:  ANDWF  55,F
06D8:  BTFSS  55.5
06D9:  GOTO   6E6
06DA:  BCF    55.5
06DB:  MOVF   54,W
06DC:  BTFSS  03.2
06DD:  DECF   55,F
06DE:  MOVF   77,W
06DF:  MOVWF  55
06E0:  MOVLW  2D
06E1:  MOVWF  5E
06E2:  CALL   1C3
06E3:  MOVF   55,W
06E4:  MOVWF  77
06E5:  CLRF   55
06E6:  MOVF   54,W
06E7:  SUBWF  57,W
06E8:  BTFSS  03.2
06E9:  GOTO   6F4
06EA:  MOVF   77,W
06EB:  MOVWF  55
06EC:  MOVLW  2E
06ED:  MOVWF  5E
06EE:  CALL   1C3
06EF:  MOVF   55,W
06F0:  MOVWF  77
06F1:  MOVLW  20
06F2:  ANDWF  55,F
06F3:  MOVLW  00
06F4:  MOVLW  30
06F5:  BTFSS  55.5
06F6:  GOTO   704
06F7:  BCF    55.5
06F8:  MOVF   54,W
06F9:  BTFSS  03.2
06FA:  DECF   55,F
06FB:  MOVF   77,W
06FC:  MOVWF  55
06FD:  MOVLW  2D
06FE:  MOVWF  5E
06FF:  CALL   1C3
0700:  MOVF   55,W
0701:  MOVWF  77
0702:  CLRF   55
0703:  MOVLW  30
0704:  ADDWF  77,F
0705:  MOVF   77,W
0706:  MOVWF  5E
0707:  CALL   1C3
0708:  BCF    03.1
0709:  MOVF   5C,W
070A:  MOVWF  60
070B:  MOVF   5B,W
070C:  MOVWF  5F
070D:  MOVF   5A,W
070E:  MOVWF  5E
070F:  MOVF   59,W
0710:  MOVWF  5D
0711:  CLRF   64
0712:  CLRF   63
0713:  CLRF   62
0714:  MOVLW  0A
0715:  MOVWF  61
0716:  CALL   5F3
0717:  MOVF   7A,W
0718:  MOVWF  5C
0719:  MOVF   79,W
071A:  MOVWF  5B
071B:  MOVF   78,W
071C:  MOVWF  5A
071D:  MOVF   77,W
071E:  MOVWF  59
071F:  DECFSZ 57,F
0720:  GOTO   6AA
0721:  RETURN
0722:  MOVF   0B,W
0723:  MOVWF  51
0724:  BCF    0B.7
0725:  BSF    03.5
0726:  BSF    03.6
0727:  BSF    0C.7
0728:  BSF    0C.0
0729:  NOP
072A:  NOP
072B:  BCF    03.5
072C:  BCF    03.6
072D:  BTFSC  51.7
072E:  BSF    0B.7
072F:  BTFSC  03.0
0730:  GOTO   759
0731:  BSF    03.6
0732:  MOVF   0C,W
0733:  ANDLW  7F
0734:  BCF    03.6
0735:  MOVWF  51
0736:  BSF    03.6
0737:  MOVF   0D,W
0738:  BCF    03.6
0739:  MOVWF  52
073A:  BSF    03.6
073B:  MOVF   0F,W
073C:  BCF    03.6
073D:  MOVWF  53
073E:  MOVF   51,W
073F:  MOVWF  5E
0740:  CALL   1C3
0741:  MOVF   52,W
0742:  BSF    03.6
0743:  MOVWF  0D
0744:  BCF    03.6
0745:  MOVF   53,W
0746:  BSF    03.6
0747:  MOVWF  0F
0748:  BCF    03.6
0749:  MOVF   0B,W
074A:  MOVWF  54
074B:  BCF    0B.7
074C:  BSF    03.5
074D:  BSF    03.6
074E:  BSF    0C.7
074F:  BSF    0C.0
0750:  NOP
0751:  NOP
0752:  BCF    03.5
0753:  BCF    03.6
0754:  BTFSC  54.7
0755:  BSF    0B.7
0756:  DECFSZ 50,F
0757:  GOTO   759
0758:  GOTO   778
0759:  BSF    03.6
075A:  RLF    0C,W
075B:  RLF    0E,W
075C:  ANDLW  7F
075D:  BCF    03.6
075E:  MOVWF  51
075F:  BSF    03.6
0760:  MOVF   0D,W
0761:  BCF    03.6
0762:  MOVWF  52
0763:  BSF    03.6
0764:  MOVF   0F,W
0765:  BCF    03.6
0766:  MOVWF  53
0767:  MOVF   51,W
0768:  MOVWF  5E
0769:  CALL   1C3
076A:  MOVF   52,W
076B:  BSF    03.6
076C:  MOVWF  0D
076D:  BCF    03.6
076E:  MOVF   53,W
076F:  BSF    03.6
0770:  MOVWF  0F
0771:  INCF   0D,F
0772:  BTFSC  03.2
0773:  INCF   0F,F
0774:  BCF    03.0
0775:  BCF    03.6
0776:  DECFSZ 50,F
0777:  GOTO   722
0778:  RETURN
*
085A:  MOVLW  80
085B:  BTFSC  03.1
085C:  XORWF  59,F
085D:  CLRF   5E
085E:  CLRF   5F
085F:  MOVF   55,W
0860:  MOVWF  5D
0861:  MOVF   59,W
0862:  XORWF  5D,F
0863:  MOVF   54,W
0864:  BTFSC  03.2
0865:  GOTO   14A
0866:  MOVWF  5C
0867:  MOVWF  77
0868:  MOVF   58,W
0869:  BTFSC  03.2
086A:  GOTO   153
086B:  SUBWF  5C,F
086C:  BTFSC  03.2
086D:  GOTO   0EF
086E:  BTFSS  03.0
086F:  GOTO   0AD
0870:  MOVF   59,W
0871:  MOVWF  62
0872:  BSF    62.7
0873:  MOVF   5A,W
0874:  MOVWF  61
0875:  MOVF   5B,W
0876:  MOVWF  60
0877:  CLRF   5F
0878:  BCF    03.0
0879:  RRF    62,F
087A:  RRF    61,F
087B:  RRF    60,F
087C:  RRF    5F,F
087D:  DECFSZ 5C,F
087E:  GOTO   077
087F:  BTFSS  5D.7
0880:  GOTO   084
0881:  BSF    5E.0
0882:  GOTO   167
0883:  BCF    5E.0
0884:  BCF    5C.0
0885:  BSF    5E.4
0886:  MOVLW  57
0887:  MOVWF  04
0888:  BCF    03.7
0889:  GOTO   17C
088A:  BCF    5E.4
088B:  BTFSC  5D.7
088C:  GOTO   097
088D:  BTFSS  5C.0
088E:  GOTO   0A2
088F:  RRF    62,F
0890:  RRF    61,F
0891:  RRF    60,F
0892:  RRF    5F,F
0893:  INCF   77,F
0894:  BTFSC  03.2
0895:  GOTO   162
0896:  GOTO   0A2
0897:  BTFSC  62.7
0898:  GOTO   0A5
0899:  BCF    03.0
089A:  RLF    5F,F
089B:  RLF    60,F
089C:  RLF    61,F
089D:  RLF    62,F
089E:  DECF   77,F
089F:  BTFSC  03.2
08A0:  GOTO   162
08A1:  GOTO   097
08A2:  BSF    5E.6
08A3:  GOTO   10F
08A4:  BCF    5E.6
08A5:  MOVF   55,W
08A6:  MOVWF  5D
08A7:  BTFSS  5D.7
08A8:  GOTO   0AB
08A9:  BSF    62.7
08AA:  GOTO   15B
08AB:  BCF    62.7
08AC:  GOTO   15B
08AD:  MOVF   58,W
08AE:  MOVWF  5C
08AF:  MOVWF  77
08B0:  MOVF   54,W
08B1:  SUBWF  5C,F
08B2:  MOVF   55,W
08B3:  MOVWF  62
08B4:  BSF    62.7
08B5:  MOVF   56,W
08B6:  MOVWF  61
08B7:  MOVF   57,W
08B8:  MOVWF  60
08B9:  CLRF   5F
08BA:  BCF    03.0
08BB:  RRF    62,F
08BC:  RRF    61,F
08BD:  RRF    60,F
08BE:  RRF    5F,F
08BF:  DECFSZ 5C,F
08C0:  GOTO   0B9
08C1:  BTFSS  5D.7
08C2:  GOTO   0C6
08C3:  BSF    5E.1
08C4:  GOTO   167
08C5:  BCF    5E.1
08C6:  BCF    5C.0
08C7:  BSF    5E.5
08C8:  MOVLW  5B
08C9:  MOVWF  04
08CA:  BCF    03.7
08CB:  GOTO   17C
08CC:  BCF    5E.5
08CD:  BTFSC  5D.7
08CE:  GOTO   0D9
08CF:  BTFSS  5C.0
08D0:  GOTO   0E4
08D1:  RRF    62,F
08D2:  RRF    61,F
08D3:  RRF    60,F
08D4:  RRF    5F,F
08D5:  INCF   77,F
08D6:  BTFSC  03.2
08D7:  GOTO   162
08D8:  GOTO   0E4
08D9:  BTFSC  62.7
08DA:  GOTO   0E7
08DB:  BCF    03.0
08DC:  RLF    5F,F
08DD:  RLF    60,F
08DE:  RLF    61,F
08DF:  RLF    62,F
08E0:  DECF   77,F
08E1:  BTFSC  03.2
08E2:  GOTO   162
08E3:  GOTO   0D9
08E4:  BSF    5E.7
08E5:  GOTO   10F
08E6:  BCF    5E.7
08E7:  MOVF   59,W
08E8:  MOVWF  5D
08E9:  BTFSS  5D.7
08EA:  GOTO   0ED
08EB:  BSF    62.7
08EC:  GOTO   15B
08ED:  BCF    62.7
08EE:  GOTO   15B
08EF:  MOVF   59,W
08F0:  MOVWF  62
08F1:  BSF    62.7
08F2:  MOVF   5A,W
08F3:  MOVWF  61
08F4:  MOVF   5B,W
08F5:  MOVWF  60
08F6:  BTFSS  5D.7
08F7:  GOTO   0FC
08F8:  BCF    62.7
08F9:  BSF    5E.2
08FA:  GOTO   167
08FB:  BCF    5E.2
08FC:  CLRF   5F
08FD:  BCF    5C.0
08FE:  MOVLW  57
08FF:  MOVWF  04
0900:  BCF    03.7
0901:  GOTO   17C
0902:  BTFSC  5D.7
0903:  GOTO   125
0904:  MOVF   55,W
0905:  MOVWF  5D
0906:  BTFSS  5C.0
0907:  GOTO   10F
0908:  RRF    62,F
0909:  RRF    61,F
090A:  RRF    60,F
090B:  RRF    5F,F
090C:  INCF   77,F
090D:  BTFSC  03.2
090E:  GOTO   162
090F:  BTFSS  5F.7
0910:  GOTO   120
0911:  INCF   60,F
0912:  BTFSS  03.2
0913:  GOTO   120
0914:  INCF   61,F
0915:  BTFSS  03.2
0916:  GOTO   120
0917:  INCF   62,F
0918:  BTFSS  03.2
0919:  GOTO   120
091A:  RRF    62,F
091B:  RRF    61,F
091C:  RRF    60,F
091D:  INCF   77,F
091E:  BTFSC  03.2
091F:  GOTO   162
0920:  BTFSC  5E.6
0921:  GOTO   0A4
0922:  BTFSC  5E.7
0923:  GOTO   0E6
0924:  GOTO   144
0925:  MOVLW  80
0926:  XORWF  62,F
0927:  BTFSS  62.7
0928:  GOTO   12D
0929:  GOTO   167
092A:  MOVF   59,W
092B:  MOVWF  5D
092C:  GOTO   13A
092D:  MOVF   55,W
092E:  MOVWF  5D
092F:  MOVF   62,F
0930:  BTFSS  03.2
0931:  GOTO   13A
0932:  MOVF   61,F
0933:  BTFSS  03.2
0934:  GOTO   13A
0935:  MOVF   60,F
0936:  BTFSS  03.2
0937:  GOTO   13A
0938:  CLRF   77
0939:  GOTO   15B
093A:  BTFSC  62.7
093B:  GOTO   144
093C:  BCF    03.0
093D:  RLF    5F,F
093E:  RLF    60,F
093F:  RLF    61,F
0940:  RLF    62,F
0941:  DECFSZ 77,F
0942:  GOTO   13A
0943:  GOTO   162
0944:  BTFSS  5D.7
0945:  GOTO   148
0946:  BSF    62.7
0947:  GOTO   15B
0948:  BCF    62.7
0949:  GOTO   15B
094A:  MOVF   58,W
094B:  MOVWF  77
094C:  MOVF   59,W
094D:  MOVWF  62
094E:  MOVF   5A,W
094F:  MOVWF  61
0950:  MOVF   5B,W
0951:  MOVWF  60
0952:  GOTO   15B
0953:  MOVF   54,W
0954:  MOVWF  77
0955:  MOVF   55,W
0956:  MOVWF  62
0957:  MOVF   56,W
0958:  MOVWF  61
0959:  MOVF   57,W
095A:  MOVWF  60
095B:  MOVF   62,W
095C:  MOVWF  78
095D:  MOVF   61,W
095E:  MOVWF  79
095F:  MOVF   60,W
0960:  MOVWF  7A
0961:  GOTO   19A
0962:  CLRF   77
0963:  CLRF   78
0964:  CLRF   79
0965:  CLRF   7A
0966:  GOTO   19A
0967:  CLRF   5F
0968:  COMF   60,F
0969:  COMF   61,F
096A:  COMF   62,F
096B:  COMF   5F,F
096C:  INCF   5F,F
096D:  BTFSS  03.2
096E:  GOTO   175
096F:  INCF   60,F
0970:  BTFSS  03.2
0971:  GOTO   175
0972:  INCF   61,F
0973:  BTFSC  03.2
0974:  INCF   62,F
0975:  BTFSC  5E.0
0976:  GOTO   083
0977:  BTFSC  5E.1
0978:  GOTO   0C5
0979:  BTFSC  5E.2
097A:  GOTO   0FB
097B:  GOTO   12A
097C:  MOVF   00,W
097D:  ADDWF  60,F
097E:  BTFSS  03.0
097F:  GOTO   186
0980:  INCF   61,F
0981:  BTFSS  03.2
0982:  GOTO   186
0983:  INCF   62,F
0984:  BTFSC  03.2
0985:  BSF    5C.0
0986:  DECF   04,F
0987:  MOVF   00,W
0988:  ADDWF  61,F
0989:  BTFSS  03.0
098A:  GOTO   18E
098B:  INCF   62,F
098C:  BTFSC  03.2
098D:  BSF    5C.0
098E:  DECF   04,F
098F:  MOVF   00,W
0990:  BTFSS  00.7
0991:  XORLW  80
0992:  ADDWF  62,F
0993:  BTFSC  03.0
0994:  BSF    5C.0
0995:  BTFSC  5E.4
0996:  GOTO   08A
0997:  BTFSC  5E.5
0998:  GOTO   0CC
0999:  GOTO   102
*
09A2:  MOVLW  8E
09A3:  MOVWF  77
09A4:  MOVF   50,W
09A5:  SUBWF  77,F
09A6:  MOVF   51,W
09A7:  MOVWF  79
09A8:  MOVF   52,W
09A9:  MOVWF  78
09AA:  BSF    79.7
09AB:  MOVF   77,F
09AC:  BTFSC  03.2
09AD:  GOTO   1B9
09AE:  BCF    03.0
09AF:  MOVF   79,F
09B0:  BTFSS  03.2
09B1:  GOTO   1B5
09B2:  MOVF   78,F
09B3:  BTFSC  03.2
09B4:  GOTO   1B9
09B5:  RRF    79,F
09B6:  RRF    78,F
09B7:  DECFSZ 77,F
09B8:  GOTO   1AE
09B9:  BTFSS  51.7
09BA:  GOTO   1C0
09BB:  COMF   78,F
09BC:  COMF   79,F
09BD:  INCF   78,F
09BE:  BTFSC  03.2
09BF:  INCF   79,F
*
09D4:  MOVF   51,W
09D5:  BTFSC  03.2
09D6:  GOTO   299
09D7:  MOVWF  5D
09D8:  MOVF   55,W
09D9:  BTFSC  03.2
09DA:  GOTO   299
09DB:  SUBWF  5D,F
09DC:  BTFSS  03.0
09DD:  GOTO   1E3
09DE:  MOVLW  7F
09DF:  ADDWF  5D,F
09E0:  BTFSC  03.0
09E1:  GOTO   299
09E2:  GOTO   1E9
09E3:  MOVLW  81
09E4:  SUBWF  5D,F
09E5:  BTFSS  03.0
09E6:  GOTO   299
09E7:  BTFSC  03.2
09E8:  GOTO   299
09E9:  MOVF   5D,W
09EA:  MOVWF  77
09EB:  CLRF   78
09EC:  CLRF   79
09ED:  CLRF   7A
09EE:  CLRF   5C
09EF:  MOVF   52,W
09F0:  MOVWF  5B
09F1:  BSF    5B.7
09F2:  MOVF   53,W
09F3:  MOVWF  5A
09F4:  MOVF   54,W
09F5:  MOVWF  59
09F6:  MOVLW  19
09F7:  MOVWF  5D
09F8:  MOVF   58,W
09F9:  SUBWF  59,F
09FA:  BTFSC  03.0
09FB:  GOTO   20C
09FC:  MOVLW  01
09FD:  SUBWF  5A,F
09FE:  BTFSC  03.0
09FF:  GOTO   20C
0A00:  SUBWF  5B,F
0A01:  BTFSC  03.0
0A02:  GOTO   20C
0A03:  SUBWF  5C,F
0A04:  BTFSC  03.0
0A05:  GOTO   20C
0A06:  INCF   5C,F
0A07:  INCF   5B,F
0A08:  INCF   5A,F
0A09:  MOVF   58,W
0A0A:  ADDWF  59,F
0A0B:  GOTO   23E
0A0C:  MOVF   57,W
0A0D:  SUBWF  5A,F
0A0E:  BTFSC  03.0
0A0F:  GOTO   227
0A10:  MOVLW  01
0A11:  SUBWF  5B,F
0A12:  BTFSC  03.0
0A13:  GOTO   227
0A14:  SUBWF  5C,F
0A15:  BTFSC  03.0
0A16:  GOTO   227
0A17:  INCF   5C,F
0A18:  INCF   5B,F
0A19:  MOVF   57,W
0A1A:  ADDWF  5A,F
0A1B:  MOVF   58,W
0A1C:  ADDWF  59,F
0A1D:  BTFSS  03.0
0A1E:  GOTO   23E
0A1F:  INCF   5A,F
0A20:  BTFSS  03.2
0A21:  GOTO   23E
0A22:  INCF   5B,F
0A23:  BTFSS  03.2
0A24:  GOTO   23E
0A25:  INCF   5C,F
0A26:  GOTO   23E
0A27:  MOVF   56,W
0A28:  IORLW  80
0A29:  SUBWF  5B,F
0A2A:  BTFSC  03.0
0A2B:  GOTO   23D
0A2C:  MOVLW  01
0A2D:  SUBWF  5C,F
0A2E:  BTFSC  03.0
0A2F:  GOTO   23D
0A30:  INCF   5C,F
0A31:  MOVF   56,W
0A32:  IORLW  80
0A33:  ADDWF  5B,F
0A34:  MOVF   57,W
0A35:  ADDWF  5A,F
0A36:  BTFSS  03.0
0A37:  GOTO   21B
0A38:  INCF   5B,F
0A39:  BTFSS  03.2
0A3A:  GOTO   21B
0A3B:  INCF   5C,F
0A3C:  GOTO   21B
0A3D:  BSF    7A.0
0A3E:  DECFSZ 5D,F
0A3F:  GOTO   241
0A40:  GOTO   24C
0A41:  BCF    03.0
0A42:  RLF    59,F
0A43:  RLF    5A,F
0A44:  RLF    5B,F
0A45:  RLF    5C,F
0A46:  BCF    03.0
0A47:  RLF    7A,F
0A48:  RLF    79,F
0A49:  RLF    78,F
0A4A:  RLF    5E,F
0A4B:  GOTO   1F8
0A4C:  BTFSS  5E.0
0A4D:  GOTO   254
0A4E:  BCF    03.0
0A4F:  RRF    78,F
0A50:  RRF    79,F
0A51:  RRF    7A,F
0A52:  RRF    5E,F
0A53:  GOTO   257
0A54:  DECF   77,F
0A55:  BTFSC  03.2
0A56:  GOTO   299
0A57:  BTFSC  5E.7
0A58:  GOTO   280
0A59:  BCF    03.0
0A5A:  RLF    59,F
0A5B:  RLF    5A,F
0A5C:  RLF    5B,F
0A5D:  RLF    5C,F
0A5E:  MOVF   58,W
0A5F:  SUBWF  59,F
0A60:  BTFSC  03.0
0A61:  GOTO   26C
0A62:  MOVLW  01
0A63:  SUBWF  5A,F
0A64:  BTFSC  03.0
0A65:  GOTO   26C
0A66:  SUBWF  5B,F
0A67:  BTFSC  03.0
0A68:  GOTO   26C
0A69:  SUBWF  5C,F
0A6A:  BTFSS  03.0
0A6B:  GOTO   28F
0A6C:  MOVF   57,W
0A6D:  SUBWF  5A,F
0A6E:  BTFSC  03.0
0A6F:  GOTO   277
0A70:  MOVLW  01
0A71:  SUBWF  5B,F
0A72:  BTFSC  03.0
0A73:  GOTO   277
0A74:  SUBWF  5C,F
0A75:  BTFSS  03.0
0A76:  GOTO   28F
0A77:  MOVF   56,W
0A78:  IORLW  80
0A79:  SUBWF  5B,F
0A7A:  BTFSC  03.0
0A7B:  GOTO   280
0A7C:  MOVLW  01
0A7D:  SUBWF  5C,F
0A7E:  BTFSS  03.0
0A7F:  GOTO   28F
0A80:  INCF   7A,F
0A81:  BTFSS  03.2
0A82:  GOTO   28F
0A83:  INCF   79,F
0A84:  BTFSS  03.2
0A85:  GOTO   28F
0A86:  INCF   78,F
0A87:  BTFSS  03.2
0A88:  GOTO   28F
0A89:  INCF   77,F
0A8A:  BTFSC  03.2
0A8B:  GOTO   299
0A8C:  RRF    78,F
0A8D:  RRF    79,F
0A8E:  RRF    7A,F
0A8F:  MOVF   52,W
0A90:  MOVWF  5D
0A91:  MOVF   56,W
0A92:  XORWF  5D,F
0A93:  BTFSS  5D.7
0A94:  GOTO   297
0A95:  BSF    78.7
0A96:  GOTO   29D
0A97:  BCF    78.7
0A98:  GOTO   29D
0A99:  CLRF   77
0A9A:  CLRF   78
0A9B:  CLRF   79
0A9C:  CLRF   7A
....................  
.................... #list 
....................  
.................... #use delay(clock=4000000,crystal) 
*
00CF:  MOVLW  5F
00D0:  MOVWF  04
00D1:  BCF    03.7
00D2:  MOVF   00,W
00D3:  BTFSC  03.2
00D4:  GOTO   0E3
00D5:  MOVLW  01
00D6:  MOVWF  78
00D7:  CLRF   77
00D8:  DECFSZ 77,F
00D9:  GOTO   0D8
00DA:  DECFSZ 78,F
00DB:  GOTO   0D7
00DC:  MOVLW  4A
00DD:  MOVWF  77
00DE:  DECFSZ 77,F
00DF:  GOTO   0DE
00E0:  GOTO   0E1
00E1:  DECFSZ 00,F
00E2:  GOTO   0D5
00E3:  RETURN
.................... #use rs232(baud=57600,xmit=pin_c6,rcv=pin_c7) 
.................... #fuses xt,noprotect,nowdt,nobrownout,noput,nolvp 
.................... #define use_portb_lcd True 
.................... #define use_portb_kbd True 
.................... #include <lcd.c> 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00FC:  MOVLW  0F
00FD:  BSF    03.5
00FE:  ANDWF  06,W
00FF:  IORLW  F0
0100:  MOVWF  06
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
0101:  BCF    03.5
0102:  BSF    06.2
....................    delay_cycles(1); 
0103:  NOP
....................    lcd_output_enable(1); 
0104:  BSF    06.0
....................    delay_cycles(1); 
0105:  NOP
....................    high = lcd_read_nibble(); 
0106:  CALL   0F0
0107:  MOVF   78,W
0108:  MOVWF  66
....................        
....................    lcd_output_enable(0); 
0109:  BCF    06.0
....................    delay_cycles(1); 
010A:  NOP
....................    lcd_output_enable(1); 
010B:  BSF    06.0
....................    delay_us(1); 
010C:  NOP
....................    low = lcd_read_nibble(); 
010D:  CALL   0F0
010E:  MOVF   78,W
010F:  MOVWF  65
....................        
....................    lcd_output_enable(0); 
0110:  BCF    06.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0111:  MOVLW  0F
0112:  BSF    03.5
0113:  ANDWF  06,W
0114:  MOVWF  06
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0115:  BCF    03.5
0116:  SWAPF  66,W
0117:  MOVWF  77
0118:  MOVLW  F0
0119:  ANDWF  77,F
011A:  MOVF   77,W
011B:  IORWF  65,W
011C:  MOVWF  78
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00F0:  MOVF   06,W
00F1:  MOVWF  77
00F2:  SWAPF  06,W
00F3:  ANDLW  0F
00F4:  MOVWF  78
....................   #endif 
00F5:  RETURN
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00E4:  SWAPF  66,W
00E5:  ANDLW  F0
00E6:  MOVWF  77
00E7:  MOVLW  0F
00E8:  ANDWF  06,W
00E9:  IORWF  77,W
00EA:  MOVWF  06
....................   #endif 
....................        
....................    delay_cycles(1); 
00EB:  NOP
....................    lcd_output_enable(1); 
00EC:  BSF    06.0
....................    delay_us(2); 
00ED:  GOTO   0EE
....................    lcd_output_enable(0); 
00EE:  BCF    06.0
00EF:  RETURN
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
*
00F6:  BSF    03.5
00F7:  BCF    06.0
....................    lcd_rs_tris(); 
00F8:  BCF    06.1
....................    lcd_rw_tris(); 
00F9:  BCF    06.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
00FA:  BCF    03.5
00FB:  BCF    06.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
*
011D:  MOVF   78,W
011E:  MOVWF  65
011F:  BTFSC  65.7
0120:  GOTO   0FC
....................    lcd_output_rs(address); 
0121:  BTFSS  63.0
0122:  BCF    06.1
0123:  BTFSC  63.0
0124:  BSF    06.1
....................    delay_cycles(1); 
0125:  NOP
....................    lcd_output_rw(0); 
0126:  BCF    06.2
....................    delay_cycles(1); 
0127:  NOP
....................    lcd_output_enable(0); 
0128:  BCF    06.0
....................    lcd_send_nibble(n >> 4); 
0129:  SWAPF  64,W
012A:  MOVWF  65
012B:  MOVLW  0F
012C:  ANDWF  65,F
012D:  MOVF   65,W
012E:  MOVWF  66
012F:  CALL   0E4
....................    lcd_send_nibble(n & 0xf); 
0130:  MOVF   64,W
0131:  ANDLW  0F
0132:  MOVWF  65
0133:  MOVWF  66
0134:  CALL   0E4
0135:  RETURN
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
0136:  MOVLW  28
0137:  MOVWF  51
0138:  MOVLW  0C
0139:  MOVWF  52
013A:  MOVLW  01
013B:  MOVWF  53
013C:  MOVLW  06
013D:  MOVWF  54
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
013E:  BCF    06.0
....................    lcd_output_rs(0); 
013F:  BCF    06.1
....................    lcd_output_rw(0); 
0140:  BCF    06.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
0141:  MOVLW  0F
0142:  BSF    03.5
0143:  ANDWF  06,W
0144:  MOVWF  06
....................   #endif 
....................    lcd_enable_tris(); 
0145:  BCF    06.0
....................    lcd_rs_tris(); 
0146:  BCF    06.1
....................    lcd_rw_tris(); 
0147:  BCF    06.2
....................  #endif 
....................      
....................    delay_ms(15); 
0148:  MOVLW  0F
0149:  BCF    03.5
014A:  MOVWF  5F
014B:  CALL   0CF
....................    for(i=1;i<=3;++i) 
014C:  MOVLW  01
014D:  MOVWF  50
014E:  MOVF   50,W
014F:  SUBLW  03
0150:  BTFSS  03.0
0151:  GOTO   15A
....................    { 
....................        lcd_send_nibble(3); 
0152:  MOVLW  03
0153:  MOVWF  66
0154:  CALL   0E4
....................        delay_ms(5); 
0155:  MOVLW  05
0156:  MOVWF  5F
0157:  CALL   0CF
0158:  INCF   50,F
0159:  GOTO   14E
....................    } 
....................     
....................    lcd_send_nibble(2); 
015A:  MOVLW  02
015B:  MOVWF  66
015C:  CALL   0E4
....................    delay_ms(5); 
015D:  MOVLW  05
015E:  MOVWF  5F
015F:  CALL   0CF
....................    for(i=0;i<=3;++i) 
0160:  CLRF   50
0161:  MOVF   50,W
0162:  SUBLW  03
0163:  BTFSS  03.0
0164:  GOTO   171
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0165:  MOVLW  51
0166:  ADDWF  50,W
0167:  MOVWF  04
0168:  BCF    03.7
0169:  MOVF   00,W
016A:  MOVWF  55
016B:  CLRF   63
016C:  MOVF   55,W
016D:  MOVWF  64
016E:  CALL   0F6
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
016F:  INCF   50,F
0170:  GOTO   161
0171:  BSF    0A.3
0172:  BCF    0A.4
0173:  GOTO   2F7 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
01B1:  DECFSZ 60,W
01B2:  GOTO   1B4
01B3:  GOTO   1B7
....................       address=LCD_LINE_TWO; 
01B4:  MOVLW  40
01B5:  MOVWF  61
01B6:  GOTO   1B8
....................    else 
....................       address=0; 
01B7:  CLRF   61
....................       
....................    address+=x-1; 
01B8:  MOVLW  01
01B9:  SUBWF  5F,W
01BA:  ADDWF  61,F
....................    lcd_send_byte(0,0x80|address); 
01BB:  MOVF   61,W
01BC:  IORLW  80
01BD:  MOVWF  62
01BE:  CLRF   63
01BF:  MOVF   62,W
01C0:  MOVWF  64
01C1:  CALL   0F6
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
01C2:  RETURN
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
01C3:  MOVF   5E,W
01C4:  XORLW  07
01C5:  BTFSC  03.2
01C6:  GOTO   1D1
01C7:  XORLW  0B
01C8:  BTFSC  03.2
01C9:  GOTO   1D6
01CA:  XORLW  06
01CB:  BTFSC  03.2
01CC:  GOTO   1DE
01CD:  XORLW  02
01CE:  BTFSC  03.2
01CF:  GOTO   1E4
01D0:  GOTO   1E9
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01D1:  MOVLW  01
01D2:  MOVWF  5F
01D3:  MOVWF  60
01D4:  CALL   1B1
01D5:  GOTO   1EE
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01D6:  CLRF   63
01D7:  MOVLW  01
01D8:  MOVWF  64
01D9:  CALL   0F6
....................                      delay_ms(2); 
01DA:  MOVLW  02
01DB:  MOVWF  5F
01DC:  CALL   0CF
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01DD:  GOTO   1EE
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01DE:  MOVLW  01
01DF:  MOVWF  5F
01E0:  MOVLW  02
01E1:  MOVWF  60
01E2:  CALL   1B1
01E3:  GOTO   1EE
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01E4:  CLRF   63
01E5:  MOVLW  10
01E6:  MOVWF  64
01E7:  CALL   0F6
01E8:  GOTO   1EE
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01E9:  MOVLW  01
01EA:  MOVWF  63
01EB:  MOVF   5E,W
01EC:  MOVWF  64
01ED:  CALL   0F6
....................      #endif 
....................    } 
01EE:  RETURN
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <kbd.c>  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             KBD.C                                 //// 
.................... ////                  Generic keypad scan driver                       //// 
.................... ////                                                                   //// 
.................... ////  kbd_init()   Must be called before any other function.           //// 
.................... ////                                                                   //// 
.................... ////  c = kbd_getc(c)  Will return a key value if pressed or /0 if not //// 
.................... ////                   This function should be called frequently so as //// 
.................... ////                   not to miss a key press.                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... ////////////////// The following defines the keypad layout on port D 
....................  
.................... // Un-comment the following define to use port B 
.................... // #define use_portb_kbd TRUE 
....................  
.................... // Make sure the port used has pull-up resistors (or the LCD) on 
.................... // the column pins 
....................  
.................... #if defined use_portb_kbd 
....................    #byte kbd = getenv("SFR:PORTB") 
.................... #else 
....................    #byte kbd = getenv("SFR:PORTD") 
.................... #endif 
....................  
.................... #if defined use_portb_kbd 
....................    #define set_tris_kbd(x) set_tris_b(x) 
.................... #else 
....................    #define set_tris_kbd(x) set_tris_d(x) 
.................... #endif 
....................  
.................... //Keypad connection:   (for example column 0 is B2) 
.................... //                Bx: 
....................  
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad 
.................... #define COL0 (1 << 2) 
.................... #define COL1 (1 << 3) 
.................... #define COL2 (1 << 6) 
....................  
.................... #define ROW0 (1 << 4) 
.................... #define ROW1 (1 << 7) 
.................... #define ROW2 (1 << 1) 
.................... #define ROW3 (1 << 5) 
....................  
.................... #else ////////////////////////////////////////////////// For the black keypad 
.................... #define COL0 (1 << 5) 
.................... #define COL1 (1 << 6) 
.................... #define COL2 (1 << 7) 
....................  
.................... #define ROW0 (1 << 1) 
.................... #define ROW1 (1 << 2) 
.................... #define ROW2 (1 << 3) 
.................... #define ROW3 (1 << 4) 
....................  
.................... #endif 
....................  
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3) 
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2) 
....................  
.................... // Keypad layout: 
.................... char const KEYS[4][3] = {{'1','2','3'}, 
....................                          {'4','5','6'}, 
....................                          {'7','8','9'}, 
....................                          {'*','0','#'}}; 
....................  
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where 
....................                                   // n is the number of times you expect 
....................                                   // to call kbd_getc each second 
....................  
....................  
.................... void kbd_init() { 
*
0174:  BSF    0A.3
0175:  BCF    0A.4
0176:  GOTO   2FA (RETURN)
.................... } 
....................  
.................... char kbd_getc( ) { 
....................    static BYTE kbd_call_count; 
*
0AD3:  BCF    03.6
0AD4:  CLRF   2B
....................    static int1 kbd_down; 
0AD5:  BCF    2C.0
....................    static char last_key; 
0AD6:  CLRF   2D
....................    static BYTE col; 
0AD7:  CLRF   2E
....................  
....................    BYTE kchar; 
....................    BYTE row; 
....................  
....................    kchar='\0'; 
*
0245:  CLRF   5B
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) { 
0246:  INCF   2B,F
0247:  MOVF   2B,W
0248:  SUBLW  21
0249:  BTFSC  03.0
024A:  GOTO   2A3
....................        switch (col) { 
024B:  MOVF   2E,W
024C:  BTFSC  03.2
024D:  GOTO   255
024E:  XORLW  01
024F:  BTFSC  03.2
0250:  GOTO   25B
0251:  XORLW  03
0252:  BTFSC  03.2
0253:  GOTO   261
0254:  GOTO   266
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0); 
0255:  MOVLW  DE
0256:  BSF    03.5
0257:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS; 
0258:  BCF    03.5
0259:  MOVWF  06
....................                     break; 
025A:  GOTO   266
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1); 
025B:  MOVLW  BE
025C:  BSF    03.5
025D:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS; 
025E:  BCF    03.5
025F:  MOVWF  06
....................                     break; 
0260:  GOTO   266
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2); 
0261:  MOVLW  7E
0262:  BSF    03.5
0263:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS; 
0264:  BCF    03.5
0265:  MOVWF  06
....................                     break; 
....................        } 
....................  
....................        if(kbd_down) { 
0266:  BTFSS  2C.0
0267:  GOTO   272
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) { 
0268:  MOVF   06,W
0269:  ANDLW  1E
026A:  SUBLW  1E
026B:  BTFSS  03.2
026C:  GOTO   271
....................            kbd_down=FALSE; 
026D:  BCF    2C.0
....................            kchar=last_key; 
026E:  MOVF   2D,W
026F:  MOVWF  5B
....................            last_key='\0'; 
0270:  CLRF   2D
....................          } 
....................        } else { 
0271:  GOTO   2A2
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) { 
0272:  MOVF   06,W
0273:  ANDLW  1E
0274:  SUBLW  1E
0275:  BTFSC  03.2
0276:  GOTO   29D
....................              if((kbd & ROW0)==0) 
0277:  MOVF   06,W
0278:  ANDLW  02
0279:  BTFSS  03.2
027A:  GOTO   27D
....................                row=0; 
027B:  CLRF   5C
027C:  GOTO   291
....................              else if((kbd & ROW1)==0) 
027D:  MOVF   06,W
027E:  ANDLW  04
027F:  BTFSS  03.2
0280:  GOTO   284
....................                row=1; 
0281:  MOVLW  01
0282:  MOVWF  5C
0283:  GOTO   291
....................              else if((kbd & ROW2)==0) 
0284:  MOVF   06,W
0285:  ANDLW  08
0286:  BTFSS  03.2
0287:  GOTO   28B
....................                row=2; 
0288:  MOVLW  02
0289:  MOVWF  5C
028A:  GOTO   291
....................              else if((kbd & ROW3)==0) 
028B:  MOVF   06,W
028C:  ANDLW  10
028D:  BTFSS  03.2
028E:  GOTO   291
....................                row=3; 
028F:  MOVLW  03
0290:  MOVWF  5C
....................              last_key =KEYS[row][col]; 
0291:  MOVF   5C,W
0292:  MOVWF  65
0293:  MOVLW  03
0294:  MOVWF  66
0295:  CALL   18C
0296:  MOVF   2E,W
0297:  ADDWF  78,W
0298:  CALL   051
0299:  MOVWF  78
029A:  MOVWF  2D
....................              kbd_down = TRUE; 
029B:  BSF    2C.0
....................           } else { 
029C:  GOTO   2A2
....................              ++col; 
029D:  INCF   2E,F
....................              if(col==3) 
029E:  MOVF   2E,W
029F:  SUBLW  03
02A0:  BTFSC  03.2
....................                col=0; 
02A1:  CLRF   2E
....................           } 
....................        } 
....................       kbd_call_count=0; 
02A2:  CLRF   2B
....................    } 
....................   set_tris_kbd(ALL_PINS); 
02A3:  MOVLW  FE
02A4:  BSF    03.5
02A5:  MOVWF  06
....................   return(kchar); 
02A6:  BCF    03.5
02A7:  MOVF   5B,W
02A8:  MOVWF  78
02A9:  RETURN
.................... } 
....................  
.................... #include <stdio.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDIO 
.................... #define _STDIO 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
0AD8:  CLRF   2F
0AD9:  CLRF   30
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #ifndef getc 
.................... #define getc getch 
.................... #define getchar getch 
.................... #define puts(s) {printf(s); putchar(13); putchar(10);} 
.................... #define putc putchar 
.................... #endif 
.................... /* maps error number to an error message. Writes a sequence of characters to 
.................... stderr stream thus: if s is not null then string pointed to by s follwed by 
.................... a colon (:) and a space and the appropriate error message returned by strerror 
.................... function with argument errno 
....................  
.................... Returns: no value 
.................... */ 
....................  
.................... #ifdef _ERRNO 
.................... void perror(char *s) 
.................... { 
....................   if(s) 
....................   fprintf(STDERR,"%s: ",s); 
....................   fprintf(STDERR,"%s\r\n",strerror(errno)); 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #include <stdbool.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                          stdbool.h                                //// 
.................... ////                                                                   //// 
.................... //// Standard boolean definitions                                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __STDBOOL_H__ 
.................... #define __STDBOOL_H__ 
....................  
.................... //remove TRUE and FALSE added by CCS's device .h file 
.................... #if defined(TRUE) 
.................... #undef TRUE 
.................... #endif 
.................... #if defined(FALSE) 
.................... #undef FALSE 
.................... #endif 
....................  
.................... typedef int1   bool; 
.................... #define true   1 
.................... #define false  0 
.................... #define __bool_true_false_are_defined  1 
....................  
.................... #endif 
....................  
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #byte PORTA= 5 
.................... #byte PORTB= 6 
.................... #byte PORTC= 7 
.................... #define LED1 PORTC,4 
.................... #define LED2 PORTC,5 
....................  
.................... // VAR PARA RS232 
.................... int valor; 
.................... // ----- INT_RDA ---- 
.................... #int_RDA 
.................... RDA_isr() 
.................... { 
....................    valor=getc(); 
*
0061:  BTFSS  0C.5
0062:  GOTO   061
0063:  MOVF   1A,W
0064:  MOVWF  31
....................    return valor; 
0065:  MOVF   31,W
0066:  MOVWF  78
0067:  BCF    0C.5
0068:  BCF    0A.3
0069:  BCF    0A.4
006A:  GOTO   02D
.................... } 
.................... // VAR PARA EEPROM 
.................... char K; 
.................... int8 MIL,CEN,DEC,UNI,VAL; 
.................... int16 contra=9999; 
.................... int8 sinal; 
....................  
.................... // VAR PARA ADC 
.................... long bits; 
.................... float tem=0; 
.................... int i=0; 
....................  
....................  
.................... // ------------------- TECLADO ------------------- 
.................... void teclado() 
.................... { 
....................    k=kbd_getc();  
*
02AA:  CALL   245
02AB:  MOVF   78,W
02AC:  MOVWF  32
....................    while(k=='\0') 
02AD:  MOVF   32,F
02AE:  BTFSS  03.2
02AF:  GOTO   2B4
....................    { 
....................       k=kbd_getc(); 
02B0:  CALL   245
02B1:  MOVF   78,W
02B2:  MOVWF  32
02B3:  GOTO   2AD
....................    } 
....................    if( (k!='\0')) 
02B4:  MOVF   32,F
02B5:  BTFSC  03.2
02B6:  GOTO   2F1
....................    { 
....................       if(K=='0') 
02B7:  MOVF   32,W
02B8:  SUBLW  30
02B9:  BTFSC  03.2
....................          VAL=0; 
02BA:  CLRF   37
....................       if(K=='1') 
02BB:  MOVF   32,W
02BC:  SUBLW  31
02BD:  BTFSS  03.2
02BE:  GOTO   2C1
....................          VAL=1; 
02BF:  MOVLW  01
02C0:  MOVWF  37
....................       if(K=='2') 
02C1:  MOVF   32,W
02C2:  SUBLW  32
02C3:  BTFSS  03.2
02C4:  GOTO   2C7
....................          VAL=2; 
02C5:  MOVLW  02
02C6:  MOVWF  37
....................       if(K=='3') 
02C7:  MOVF   32,W
02C8:  SUBLW  33
02C9:  BTFSS  03.2
02CA:  GOTO   2CD
....................          VAL=3; 
02CB:  MOVLW  03
02CC:  MOVWF  37
....................       if(K=='4') 
02CD:  MOVF   32,W
02CE:  SUBLW  34
02CF:  BTFSS  03.2
02D0:  GOTO   2D3
....................          VAL=4; 
02D1:  MOVLW  04
02D2:  MOVWF  37
....................       if(K=='5') 
02D3:  MOVF   32,W
02D4:  SUBLW  35
02D5:  BTFSS  03.2
02D6:  GOTO   2D9
....................          VAL=5; 
02D7:  MOVLW  05
02D8:  MOVWF  37
....................       if(K=='6') 
02D9:  MOVF   32,W
02DA:  SUBLW  36
02DB:  BTFSS  03.2
02DC:  GOTO   2DF
....................          VAL=6; 
02DD:  MOVLW  06
02DE:  MOVWF  37
....................       if(K=='7') 
02DF:  MOVF   32,W
02E0:  SUBLW  37
02E1:  BTFSS  03.2
02E2:  GOTO   2E5
....................          VAL=7; 
02E3:  MOVLW  07
02E4:  MOVWF  37
....................       if(K=='8') 
02E5:  MOVF   32,W
02E6:  SUBLW  38
02E7:  BTFSS  03.2
02E8:  GOTO   2EB
....................          VAL=8; 
02E9:  MOVLW  08
02EA:  MOVWF  37
....................       if(K=='9') 
02EB:  MOVF   32,W
02EC:  SUBLW  39
02ED:  BTFSS  03.2
02EE:  GOTO   2F1
....................          VAL=9; 
02EF:  MOVLW  09
02F0:  MOVWF  37
....................    } 
02F1:  RETURN
.................... } 
.................... // ------------------- PEDIR CLAVE ------------------- 
.................... void pedir_clave(void) 
.................... { 
....................    teclado(); 
02F2:  CALL   2AA
....................    if((k!='#')&&(k!='*')) 
02F3:  MOVF   32,W
02F4:  SUBLW  23
02F5:  BTFSC  03.2
02F6:  GOTO   300
02F7:  MOVF   32,W
02F8:  SUBLW  2A
02F9:  BTFSC  03.2
02FA:  GOTO   300
....................    { 
....................       lcd_putc('*'); 
02FB:  MOVLW  2A
02FC:  MOVWF  5E
02FD:  CALL   1C3
....................       MIL=VAL; 
02FE:  MOVF   37,W
02FF:  MOVWF  33
....................    } 
....................    if(k=='*' || k=='#') 
0300:  MOVF   32,W
0301:  SUBLW  2A
0302:  BTFSC  03.2
0303:  GOTO   307
0304:  MOVF   32,W
0305:  SUBLW  23
0306:  BTFSC  03.2
....................       return; 
0307:  GOTO   34A
....................    teclado(); 
0308:  CALL   2AA
....................    if((k!='#')&&(k!='*')) 
0309:  MOVF   32,W
030A:  SUBLW  23
030B:  BTFSC  03.2
030C:  GOTO   316
030D:  MOVF   32,W
030E:  SUBLW  2A
030F:  BTFSC  03.2
0310:  GOTO   316
....................    { 
....................       lcd_putc('*'); 
0311:  MOVLW  2A
0312:  MOVWF  5E
0313:  CALL   1C3
....................       CEN=VAL; 
0314:  MOVF   37,W
0315:  MOVWF  34
....................    } 
....................    if(k=='*' || k=='#') 
0316:  MOVF   32,W
0317:  SUBLW  2A
0318:  BTFSC  03.2
0319:  GOTO   31D
031A:  MOVF   32,W
031B:  SUBLW  23
031C:  BTFSC  03.2
....................       return; 
031D:  GOTO   34A
....................    teclado(); 
031E:  CALL   2AA
....................    if((k!='#')&&(k!='*')) 
031F:  MOVF   32,W
0320:  SUBLW  23
0321:  BTFSC  03.2
0322:  GOTO   32C
0323:  MOVF   32,W
0324:  SUBLW  2A
0325:  BTFSC  03.2
0326:  GOTO   32C
....................    { 
....................       lcd_putc('*'); 
0327:  MOVLW  2A
0328:  MOVWF  5E
0329:  CALL   1C3
....................       DEC=VAL; 
032A:  MOVF   37,W
032B:  MOVWF  35
....................    } 
....................    if(k=='*' || k=='#') 
032C:  MOVF   32,W
032D:  SUBLW  2A
032E:  BTFSC  03.2
032F:  GOTO   333
0330:  MOVF   32,W
0331:  SUBLW  23
0332:  BTFSC  03.2
....................       return; 
0333:  GOTO   34A
....................    teclado(); 
0334:  CALL   2AA
....................    if((k!='#')&&(k!='*')) 
0335:  MOVF   32,W
0336:  SUBLW  23
0337:  BTFSC  03.2
0338:  GOTO   342
0339:  MOVF   32,W
033A:  SUBLW  2A
033B:  BTFSC  03.2
033C:  GOTO   342
....................    { 
....................       lcd_putc('*'); 
033D:  MOVLW  2A
033E:  MOVWF  5E
033F:  CALL   1C3
....................       UNI=VAL; 
0340:  MOVF   37,W
0341:  MOVWF  36
....................    } 
....................    if(k=='*' || k=='#') 
0342:  MOVF   32,W
0343:  SUBLW  2A
0344:  BTFSC  03.2
0345:  GOTO   349
0346:  MOVF   32,W
0347:  SUBLW  23
0348:  BTFSC  03.2
....................       return; 
0349:  GOTO   34A
034A:  RETURN
.................... } 
.................... // ------------------- VALIDAR CLAVE ------------------- 
.................... int validar_clave(void) 
034B:  CLRF   5C
034C:  CLRF   5B
.................... { 
....................    //Variables locales 
....................    int16 clave=0,m,c,d,u; 
....................     
....................    m=MIL*1000; 
034D:  CLRF   68
034E:  MOVF   33,W
034F:  MOVWF  67
0350:  MOVLW  03
0351:  MOVWF  6A
0352:  MOVLW  E8
0353:  MOVWF  69
0354:  CALL   177
0355:  MOVF   79,W
0356:  MOVWF  5E
0357:  MOVF   78,W
0358:  MOVWF  5D
....................    //c=_mul(CEN,100);            //Alternativa para multiplicar int8*int8=int16 
....................    c=(int16)CEN*100;                   //Convierto centemas, haciendo un CAST 
0359:  CLRF   66
035A:  MOVF   34,W
035B:  MOVWF  65
035C:  MOVF   66,W
035D:  MOVWF  68
035E:  MOVF   34,W
035F:  MOVWF  67
0360:  CLRF   6A
0361:  MOVLW  64
0362:  MOVWF  69
0363:  CALL   177
0364:  MOVF   79,W
0365:  MOVWF  60
0366:  MOVF   78,W
0367:  MOVWF  5F
....................    d=DEC*10; 
0368:  MOVF   35,W
0369:  MOVWF  65
036A:  MOVLW  0A
036B:  MOVWF  66
036C:  CALL   18C
036D:  CLRF   62
036E:  MOVF   78,W
036F:  MOVWF  61
....................    u=UNI; 
0370:  CLRF   64
0371:  MOVF   36,W
0372:  MOVWF  63
....................     
....................    clave=m+c+d+u; 
0373:  MOVF   5F,W
0374:  ADDWF  5D,W
0375:  MOVWF  65
0376:  MOVF   5E,W
0377:  MOVWF  66
0378:  MOVF   60,W
0379:  BTFSC  03.0
037A:  INCFSZ 60,W
037B:  ADDWF  66,F
037C:  MOVF   61,W
037D:  ADDWF  65,F
037E:  MOVF   62,W
037F:  BTFSC  03.0
0380:  INCFSZ 62,W
0381:  ADDWF  66,F
0382:  MOVF   63,W
0383:  ADDWF  65,W
0384:  MOVWF  5B
0385:  MOVF   66,W
0386:  MOVWF  5C
0387:  MOVF   64,W
0388:  BTFSC  03.0
0389:  INCFSZ 64,W
038A:  ADDWF  5C,F
....................    MIL=0;CEN=0;DEC=0;UNI=0; 
038B:  CLRF   33
038C:  CLRF   34
038D:  CLRF   35
038E:  CLRF   36
....................     
....................    if(clave==contra) 
038F:  MOVF   38,W
0390:  SUBWF  5B,W
0391:  BTFSS  03.2
0392:  GOTO   39B
0393:  MOVF   39,W
0394:  SUBWF  5C,W
0395:  BTFSS  03.2
0396:  GOTO   39B
....................       return(1); 
0397:  MOVLW  01
0398:  MOVWF  78
0399:  GOTO   39D
039A:  GOTO   39D
....................    else 
....................       return(0); 
039B:  MOVLW  00
039C:  MOVWF  78
039D:  RETURN
.................... } 
.................... // ------------------- CAMBIO CLAVE ------------------- 
.................... void cambio_clave(void) 
039E:  CLRF   50
039F:  CLRF   52
03A0:  CLRF   51
.................... { 
....................    int bandera=0; 
....................    int16 clave=0,m,c,d,u; 
....................    LCD_PUTC("\f"); 
03A1:  MOVLW  6B
03A2:  BSF    03.6
03A3:  MOVWF  0D
03A4:  MOVLW  00
03A5:  MOVWF  0F
03A6:  BCF    03.6
03A7:  CALL   1EF
....................    LCD_GOTOXY(1,1); 
03A8:  MOVLW  01
03A9:  MOVWF  5F
03AA:  MOVWF  60
03AB:  CALL   1B1
....................    LCD_PUTC("CLAVE ACTUAL"); 
03AC:  MOVLW  6C
03AD:  BSF    03.6
03AE:  MOVWF  0D
03AF:  MOVLW  00
03B0:  MOVWF  0F
03B1:  BCF    03.6
03B2:  CALL   1EF
....................    LCD_GOTOXY(1,2);       
03B3:  MOVLW  01
03B4:  MOVWF  5F
03B5:  MOVLW  02
03B6:  MOVWF  60
03B7:  CALL   1B1
....................    pedir_clave(); 
03B8:  CALL   2F2
....................    bandera=validar_clave(); 
03B9:  CALL   34B
03BA:  MOVF   78,W
03BB:  MOVWF  50
....................     
....................    if(bandera==1) 
03BC:  DECFSZ 50,W
03BD:  GOTO   4CF
....................    { 
....................       LCD_PUTC("\f"); 
03BE:  MOVLW  73
03BF:  BSF    03.6
03C0:  MOVWF  0D
03C1:  MOVLW  00
03C2:  MOVWF  0F
03C3:  BCF    03.6
03C4:  CALL   1EF
....................       LCD_GOTOXY(1,1); 
03C5:  MOVLW  01
03C6:  MOVWF  5F
03C7:  MOVWF  60
03C8:  CALL   1B1
....................       LCD_PUTC("CLAVE NUEVA  "); 
03C9:  MOVLW  74
03CA:  BSF    03.6
03CB:  MOVWF  0D
03CC:  MOVLW  00
03CD:  MOVWF  0F
03CE:  BCF    03.6
03CF:  CALL   1EF
....................       LCD_GOTOXY(1,2);    
03D0:  MOVLW  01
03D1:  MOVWF  5F
03D2:  MOVLW  02
03D3:  MOVWF  60
03D4:  CALL   1B1
....................       teclado(); 
03D5:  CALL   2AA
....................       if((k!='#')&&(k!='*')) 
03D6:  MOVF   32,W
03D7:  SUBLW  23
03D8:  BTFSC  03.2
03D9:  GOTO   3E3
03DA:  MOVF   32,W
03DB:  SUBLW  2A
03DC:  BTFSC  03.2
03DD:  GOTO   3E3
....................       { 
....................          lcd_putc('*'); 
03DE:  MOVLW  2A
03DF:  MOVWF  5E
03E0:  CALL   1C3
....................          MIL=VAL; 
03E1:  MOVF   37,W
03E2:  MOVWF  33
....................       } 
....................       teclado(); 
03E3:  CALL   2AA
....................       if((k!='#')&&(k!='*')) 
03E4:  MOVF   32,W
03E5:  SUBLW  23
03E6:  BTFSC  03.2
03E7:  GOTO   3F1
03E8:  MOVF   32,W
03E9:  SUBLW  2A
03EA:  BTFSC  03.2
03EB:  GOTO   3F1
....................       { 
....................          lcd_putc('*'); 
03EC:  MOVLW  2A
03ED:  MOVWF  5E
03EE:  CALL   1C3
....................          CEN=VAL; 
03EF:  MOVF   37,W
03F0:  MOVWF  34
....................       } 
....................       teclado(); 
03F1:  CALL   2AA
....................       if((k!='#')&&(k!='*')) 
03F2:  MOVF   32,W
03F3:  SUBLW  23
03F4:  BTFSC  03.2
03F5:  GOTO   3FF
03F6:  MOVF   32,W
03F7:  SUBLW  2A
03F8:  BTFSC  03.2
03F9:  GOTO   3FF
....................       { 
....................          lcd_putc('*'); 
03FA:  MOVLW  2A
03FB:  MOVWF  5E
03FC:  CALL   1C3
....................          DEC=VAL; 
03FD:  MOVF   37,W
03FE:  MOVWF  35
....................       } 
....................       teclado(); 
03FF:  CALL   2AA
....................       if((k!='#')&&(k!='*')) 
0400:  MOVF   32,W
0401:  SUBLW  23
0402:  BTFSC  03.2
0403:  GOTO   40D
0404:  MOVF   32,W
0405:  SUBLW  2A
0406:  BTFSC  03.2
0407:  GOTO   40D
....................       { 
....................          lcd_putc('*'); 
0408:  MOVLW  2A
0409:  MOVWF  5E
040A:  CALL   1C3
....................          UNI=VAL; 
040B:  MOVF   37,W
040C:  MOVWF  36
....................       } 
....................        
....................       m=MIL*1000; 
040D:  CLRF   68
040E:  MOVF   33,W
040F:  MOVWF  67
0410:  MOVLW  03
0411:  MOVWF  6A
0412:  MOVLW  E8
0413:  MOVWF  69
0414:  CALL   177
0415:  MOVF   79,W
0416:  MOVWF  54
0417:  MOVF   78,W
0418:  MOVWF  53
....................       c=CEN*10; 
0419:  MOVF   34,W
041A:  MOVWF  65
041B:  MOVLW  0A
041C:  MOVWF  66
041D:  CALL   18C
041E:  CLRF   56
041F:  MOVF   78,W
0420:  MOVWF  55
....................       c=c*10; 
0421:  MOVF   56,W
0422:  MOVWF  68
0423:  MOVF   55,W
0424:  MOVWF  67
0425:  CLRF   6A
0426:  MOVLW  0A
0427:  MOVWF  69
0428:  CALL   177
0429:  MOVF   79,W
042A:  MOVWF  56
042B:  MOVF   78,W
042C:  MOVWF  55
....................       d=DEC*10; 
042D:  MOVF   35,W
042E:  MOVWF  65
042F:  MOVLW  0A
0430:  MOVWF  66
0431:  CALL   18C
0432:  CLRF   58
0433:  MOVF   78,W
0434:  MOVWF  57
....................       u=UNI; 
0435:  CLRF   5A
0436:  MOVF   36,W
0437:  MOVWF  59
....................       clave=m+c+d+u; 
0438:  MOVF   55,W
0439:  ADDWF  53,W
043A:  MOVWF  5B
043B:  MOVF   54,W
043C:  MOVWF  5C
043D:  MOVF   56,W
043E:  BTFSC  03.0
043F:  INCFSZ 56,W
0440:  ADDWF  5C,F
0441:  MOVF   57,W
0442:  ADDWF  5B,F
0443:  MOVF   58,W
0444:  BTFSC  03.0
0445:  INCFSZ 58,W
0446:  ADDWF  5C,F
0447:  MOVF   59,W
0448:  ADDWF  5B,W
0449:  MOVWF  51
044A:  MOVF   5C,W
044B:  MOVWF  52
044C:  MOVF   5A,W
044D:  BTFSC  03.0
044E:  INCFSZ 5A,W
044F:  ADDWF  52,F
....................        
....................       contra=clave; 
0450:  MOVF   52,W
0451:  MOVWF  39
0452:  MOVF   51,W
0453:  MOVWF  38
....................       WRITE_EEPROM(0,MIL); 
0454:  MOVF   0B,W
0455:  MOVWF  77
0456:  BCF    0B.7
0457:  BSF    03.6
0458:  CLRF   0D
0459:  BCF    03.6
045A:  MOVF   33,W
045B:  BSF    03.6
045C:  MOVWF  0C
045D:  BSF    03.5
045E:  BCF    0C.7
045F:  BSF    0C.2
0460:  MOVLW  55
0461:  MOVWF  0D
0462:  MOVLW  AA
0463:  MOVWF  0D
0464:  BSF    0C.1
0465:  BTFSC  0C.1
0466:  GOTO   465
0467:  BCF    0C.2
0468:  MOVF   77,W
0469:  BCF    03.5
046A:  BCF    03.6
046B:  IORWF  0B,F
....................       WRITE_EEPROM(1,CEN); 
046C:  MOVF   0B,W
046D:  MOVWF  77
046E:  BCF    0B.7
046F:  MOVLW  01
0470:  BSF    03.6
0471:  MOVWF  0D
0472:  BCF    03.6
0473:  MOVF   34,W
0474:  BSF    03.6
0475:  MOVWF  0C
0476:  BSF    03.5
0477:  BCF    0C.7
0478:  BSF    0C.2
0479:  MOVLW  55
047A:  MOVWF  0D
047B:  MOVLW  AA
047C:  MOVWF  0D
047D:  BSF    0C.1
047E:  BTFSC  0C.1
047F:  GOTO   47E
0480:  BCF    0C.2
0481:  MOVF   77,W
0482:  BCF    03.5
0483:  BCF    03.6
0484:  IORWF  0B,F
....................       WRITE_EEPROM(2,DEC); 
0485:  MOVF   0B,W
0486:  MOVWF  77
0487:  BCF    0B.7
0488:  MOVLW  02
0489:  BSF    03.6
048A:  MOVWF  0D
048B:  BCF    03.6
048C:  MOVF   35,W
048D:  BSF    03.6
048E:  MOVWF  0C
048F:  BSF    03.5
0490:  BCF    0C.7
0491:  BSF    0C.2
0492:  MOVLW  55
0493:  MOVWF  0D
0494:  MOVLW  AA
0495:  MOVWF  0D
0496:  BSF    0C.1
0497:  BTFSC  0C.1
0498:  GOTO   497
0499:  BCF    0C.2
049A:  MOVF   77,W
049B:  BCF    03.5
049C:  BCF    03.6
049D:  IORWF  0B,F
....................       WRITE_EEPROM(3,UNI); 
049E:  MOVF   0B,W
049F:  MOVWF  77
04A0:  BCF    0B.7
04A1:  MOVLW  03
04A2:  BSF    03.6
04A3:  MOVWF  0D
04A4:  BCF    03.6
04A5:  MOVF   36,W
04A6:  BSF    03.6
04A7:  MOVWF  0C
04A8:  BSF    03.5
04A9:  BCF    0C.7
04AA:  BSF    0C.2
04AB:  MOVLW  55
04AC:  MOVWF  0D
04AD:  MOVLW  AA
04AE:  MOVWF  0D
04AF:  BSF    0C.1
04B0:  BTFSC  0C.1
04B1:  GOTO   4B0
04B2:  BCF    0C.2
04B3:  MOVF   77,W
04B4:  BCF    03.5
04B5:  BCF    03.6
04B6:  IORWF  0B,F
....................       WRITE_EEPROM(4,12); 
04B7:  MOVF   0B,W
04B8:  MOVWF  77
04B9:  BCF    0B.7
04BA:  MOVLW  04
04BB:  BSF    03.6
04BC:  MOVWF  0D
04BD:  MOVLW  0C
04BE:  MOVWF  0C
04BF:  BSF    03.5
04C0:  BCF    0C.7
04C1:  BSF    0C.2
04C2:  MOVLW  55
04C3:  MOVWF  0D
04C4:  MOVLW  AA
04C5:  MOVWF  0D
04C6:  BSF    0C.1
04C7:  BTFSC  0C.1
04C8:  GOTO   4C7
04C9:  BCF    0C.2
04CA:  MOVF   77,W
04CB:  BCF    03.5
04CC:  BCF    03.6
04CD:  IORWF  0B,F
....................    } 
04CE:  GOTO   4F2
....................    else 
....................    { 
....................       LCD_PUTC("\f"); 
04CF:  MOVLW  7B
04D0:  BSF    03.6
04D1:  MOVWF  0D
04D2:  MOVLW  00
04D3:  MOVWF  0F
04D4:  BCF    03.6
04D5:  CALL   1EF
....................       LCD_GOTOXY(1,2); 
04D6:  MOVLW  01
04D7:  MOVWF  5F
04D8:  MOVLW  02
04D9:  MOVWF  60
04DA:  CALL   1B1
....................       LCD_PUTC(" CLAVE INVALIDA "); 
04DB:  MOVLW  7C
04DC:  BSF    03.6
04DD:  MOVWF  0D
04DE:  MOVLW  00
04DF:  MOVWF  0F
04E0:  BCF    03.6
04E1:  CALL   1EF
....................       BIT_SET(LED2); 
04E2:  BSF    07.5
....................       DELAY_MS(4000); 
04E3:  MOVLW  10
04E4:  MOVWF  5B
04E5:  MOVLW  FA
04E6:  MOVWF  5F
04E7:  CALL   0CF
04E8:  DECFSZ 5B,F
04E9:  GOTO   4E5
....................       BIT_CLEAR(LED2); 
04EA:  BCF    07.5
....................       LCD_PUTC("\f"); 
04EB:  MOVLW  85
04EC:  BSF    03.6
04ED:  MOVWF  0D
04EE:  MOVLW  00
04EF:  MOVWF  0F
04F0:  BCF    03.6
04F1:  CALL   1EF
....................    } 
04F2:  RETURN
.................... } 
.................... // ------------------- OBTENER TEMPERATURA ------------------- 
.................... void tomar_temp(void) 
.................... { 
....................    //while(i>=5) 
....................    //{ 
....................       set_adc_channel(0); 
*
0800:  MOVLW  00
0801:  MOVWF  78
0802:  MOVF   1F,W
0803:  ANDLW  C3
0804:  IORWF  78,W
0805:  MOVWF  1F
....................       delay_ms(1); 
0806:  MOVLW  01
0807:  MOVWF  5F
0808:  BCF    0A.3
0809:  CALL   0CF
080A:  BSF    0A.3
....................       bits=read_adc(); 
080B:  BSF    1F.1
080C:  BTFSC  1F.1
080D:  GOTO   00C
080E:  CLRF   3C
080F:  MOVF   1E,W
0810:  MOVWF  3B
....................       tem=bits*0.4882; 
0811:  MOVF   3C,W
0812:  MOVWF  52
0813:  MOVF   3B,W
0814:  MOVWF  51
0815:  BCF    0A.3
0816:  CALL   561
0817:  BSF    0A.3
0818:  MOVF   7A,W
0819:  MOVWF  60
081A:  MOVF   79,W
081B:  MOVWF  5F
081C:  MOVF   78,W
081D:  MOVWF  5E
081E:  MOVF   77,W
081F:  MOVWF  5D
0820:  MOVLW  5A
0821:  MOVWF  64
0822:  MOVLW  F5
0823:  MOVWF  63
0824:  MOVLW  79
0825:  MOVWF  62
0826:  MOVLW  7D
0827:  MOVWF  61
0828:  BCF    0A.3
0829:  CALL   57E
082A:  BSF    0A.3
082B:  MOVF   7A,W
082C:  MOVWF  40
082D:  MOVF   79,W
082E:  MOVWF  3F
082F:  MOVF   78,W
0830:  MOVWF  3E
0831:  MOVF   77,W
0832:  MOVWF  3D
....................       tem=((int)(tem * 100 + .5) / 100.0); 
0833:  MOVF   40,W
0834:  MOVWF  60
0835:  MOVF   3F,W
0836:  MOVWF  5F
0837:  MOVF   3E,W
0838:  MOVWF  5E
0839:  MOVF   3D,W
083A:  MOVWF  5D
083B:  CLRF   64
083C:  CLRF   63
083D:  MOVLW  48
083E:  MOVWF  62
083F:  MOVLW  85
0840:  MOVWF  61
0841:  BCF    0A.3
0842:  CALL   57E
0843:  BSF    0A.3
0844:  MOVF   7A,W
0845:  MOVWF  53
0846:  MOVF   79,W
0847:  MOVWF  52
0848:  MOVF   78,W
0849:  MOVWF  51
084A:  MOVF   77,W
084B:  MOVWF  50
084C:  BCF    03.1
084D:  MOVF   53,W
084E:  MOVWF  57
084F:  MOVF   52,W
0850:  MOVWF  56
0851:  MOVF   51,W
0852:  MOVWF  55
0853:  MOVF   50,W
0854:  MOVWF  54
0855:  CLRF   5B
0856:  CLRF   5A
0857:  CLRF   59
0858:  MOVLW  7E
0859:  MOVWF  58
*
099A:  MOVF   7A,W
099B:  MOVWF  53
099C:  MOVF   79,W
099D:  MOVWF  52
099E:  MOVF   78,W
099F:  MOVWF  51
09A0:  MOVF   77,W
09A1:  MOVWF  50
*
09C0:  CLRF   52
09C1:  MOVF   78,W
09C2:  MOVWF  51
09C3:  BCF    0A.3
09C4:  CALL   561
09C5:  BSF    0A.3
09C6:  MOVF   7A,W
09C7:  MOVWF  54
09C8:  MOVF   79,W
09C9:  MOVWF  53
09CA:  MOVF   78,W
09CB:  MOVWF  52
09CC:  MOVF   77,W
09CD:  MOVWF  51
09CE:  CLRF   58
09CF:  CLRF   57
09D0:  MOVLW  48
09D1:  MOVWF  56
09D2:  MOVLW  85
09D3:  MOVWF  55
*
0A9D:  MOVF   7A,W
0A9E:  MOVWF  40
0A9F:  MOVF   79,W
0AA0:  MOVWF  3F
0AA1:  MOVF   78,W
0AA2:  MOVWF  3E
0AA3:  MOVF   77,W
0AA4:  MOVWF  3D
....................       i+=1; 
0AA5:  MOVLW  01
0AA6:  ADDWF  41,F
0AA7:  RETURN
....................    //} 
.................... } 
.................... // ------------------- MAIN ------------------- 
.................... void main() 
0AA8:  MOVF   03,W
0AA9:  ANDLW  1F
0AAA:  MOVWF  03
0AAB:  BSF    03.5
0AAC:  BSF    03.6
0AAD:  BSF    07.3
0AAE:  MOVLW  10
0AAF:  BCF    03.6
0AB0:  MOVWF  19
0AB1:  MOVLW  00
0AB2:  MOVWF  1A
0AB3:  MOVLW  A6
0AB4:  MOVWF  18
0AB5:  MOVLW  90
0AB6:  BCF    03.5
0AB7:  MOVWF  18
0AB8:  MOVLW  27
0AB9:  MOVWF  39
0ABA:  MOVLW  0F
0ABB:  MOVWF  38
0ABC:  CLRF   40
0ABD:  CLRF   3F
0ABE:  CLRF   3E
0ABF:  CLRF   3D
0AC0:  CLRF   41
0AC1:  MOVLW  FF
0AC2:  MOVWF  42
0AC3:  BSF    03.5
0AC4:  BSF    03.6
0AC5:  MOVF   09,W
0AC6:  ANDLW  C0
0AC7:  MOVWF  09
0AC8:  BCF    03.6
0AC9:  BCF    1F.4
0ACA:  BCF    1F.5
0ACB:  MOVLW  00
0ACC:  BSF    03.6
0ACD:  MOVWF  08
0ACE:  BCF    03.5
0ACF:  CLRF   07
0AD0:  CLRF   08
0AD1:  CLRF   09
0AD2:  BCF    03.7
.................... { 
....................    int16 m,c,d,u; 
....................    INT8 m1,c1,d1,u1; 
....................  
....................    set_tris_a(0b00000001); 
*
0ADA:  MOVLW  01
0ADB:  BSF    03.5
0ADC:  MOVWF  05
....................    setup_adc_ports(sAN0); 
0ADD:  BSF    03.6
0ADE:  MOVF   09,W
0ADF:  ANDLW  C0
0AE0:  MOVWF  09
0AE1:  BCF    03.6
0AE2:  BCF    1F.4
0AE3:  BCF    1F.5
0AE4:  MOVLW  01
0AE5:  BSF    03.6
0AE6:  MOVWF  08
....................    setup_adc(adc_clock_internal); 
0AE7:  BCF    03.5
0AE8:  BCF    03.6
0AE9:  BSF    1F.6
0AEA:  BSF    1F.7
0AEB:  BSF    03.5
0AEC:  BCF    1F.7
0AED:  BCF    03.5
0AEE:  BSF    1F.0
....................     
....................    SET_TRIS_C(0B00000000); 
0AEF:  MOVLW  00
0AF0:  BSF    03.5
0AF1:  MOVWF  07
0AF2:  BCF    03.5
0AF3:  MOVWF  42
....................    PORTC=0; 
0AF4:  CLRF   07
....................    lcd_init(); 
0AF5:  BCF    0A.3
0AF6:  GOTO   136
0AF7:  BSF    0A.3
....................    kbd_init(); 
0AF8:  BCF    0A.3
0AF9:  GOTO   174
0AFA:  BSF    0A.3
....................    //Configura las Resistencias PULL-UP del Puerto B 
....................    port_b_pullups(0xFF);                     //PIC16F887 
0AFB:  MOVLW  FF
0AFC:  BSF    03.5
0AFD:  MOVWF  15
0AFE:  BCF    01.7
....................    //port_b_pullups(TRUE);                     //PIC16F877A 
....................     
....................    sinal=READ_EEPROM(4); 
0AFF:  MOVLW  04
0B00:  BCF    03.5
0B01:  BSF    03.6
0B02:  MOVWF  0D
0B03:  BSF    03.5
0B04:  BCF    0C.7
0B05:  BSF    0C.0
0B06:  BCF    03.5
0B07:  MOVF   0C,W
0B08:  BCF    03.6
0B09:  MOVWF  3A
....................     
....................    if(sinal!=12) 
0B0A:  MOVF   3A,W
0B0B:  SUBLW  0C
0B0C:  BTFSC  03.2
0B0D:  GOTO   313
....................       contra=9999; 
0B0E:  MOVLW  27
0B0F:  MOVWF  39
0B10:  MOVLW  0F
0B11:  MOVWF  38
0B12:  GOTO   37E
....................    else 
....................    { 
....................       m1=READ_EEPROM(0); 
0B13:  BSF    03.6
0B14:  CLRF   0D
0B15:  BSF    03.5
0B16:  BCF    0C.7
0B17:  BSF    0C.0
0B18:  BCF    03.5
0B19:  MOVF   0C,W
0B1A:  BCF    03.6
0B1B:  MOVWF  4B
....................       c1=READ_EEPROM(1);  
0B1C:  MOVLW  01
0B1D:  BSF    03.6
0B1E:  MOVWF  0D
0B1F:  BSF    03.5
0B20:  BCF    0C.7
0B21:  BSF    0C.0
0B22:  BCF    03.5
0B23:  MOVF   0C,W
0B24:  BCF    03.6
0B25:  MOVWF  4C
....................       d1=READ_EEPROM(2);  
0B26:  MOVLW  02
0B27:  BSF    03.6
0B28:  MOVWF  0D
0B29:  BSF    03.5
0B2A:  BCF    0C.7
0B2B:  BSF    0C.0
0B2C:  BCF    03.5
0B2D:  MOVF   0C,W
0B2E:  BCF    03.6
0B2F:  MOVWF  4D
....................       u1=READ_EEPROM(3);  
0B30:  MOVLW  03
0B31:  BSF    03.6
0B32:  MOVWF  0D
0B33:  BSF    03.5
0B34:  BCF    0C.7
0B35:  BSF    0C.0
0B36:  BCF    03.5
0B37:  MOVF   0C,W
0B38:  BCF    03.6
0B39:  MOVWF  4E
....................        
....................       m=m1*1000; 
0B3A:  CLRF   68
0B3B:  MOVF   4B,W
0B3C:  MOVWF  67
0B3D:  MOVLW  03
0B3E:  MOVWF  6A
0B3F:  MOVLW  E8
0B40:  MOVWF  69
0B41:  BCF    0A.3
0B42:  CALL   177
0B43:  BSF    0A.3
0B44:  MOVF   79,W
0B45:  MOVWF  44
0B46:  MOVF   78,W
0B47:  MOVWF  43
....................       //c=_mul(c1,100);          //Alternativa para multiplicar int8*int8=int16 
....................       c=(int16)c1*100;                 //Convierto centemas, haciendo un CAST 
0B48:  CLRF   51
0B49:  MOVF   4C,W
0B4A:  MOVWF  50
0B4B:  MOVF   51,W
0B4C:  MOVWF  68
0B4D:  MOVF   50,W
0B4E:  MOVWF  67
0B4F:  CLRF   6A
0B50:  MOVLW  64
0B51:  MOVWF  69
0B52:  BCF    0A.3
0B53:  CALL   177
0B54:  BSF    0A.3
0B55:  MOVF   79,W
0B56:  MOVWF  46
0B57:  MOVF   78,W
0B58:  MOVWF  45
....................       d=d1*10; 
0B59:  MOVF   4D,W
0B5A:  MOVWF  65
0B5B:  MOVLW  0A
0B5C:  MOVWF  66
0B5D:  BCF    0A.3
0B5E:  CALL   18C
0B5F:  BSF    0A.3
0B60:  CLRF   48
0B61:  MOVF   78,W
0B62:  MOVWF  47
....................       u=u1; 
0B63:  CLRF   4A
0B64:  MOVF   4E,W
0B65:  MOVWF  49
....................       contra=m+c+d+u; 
0B66:  MOVF   45,W
0B67:  ADDWF  43,W
0B68:  MOVWF  50
0B69:  MOVF   44,W
0B6A:  MOVWF  51
0B6B:  MOVF   46,W
0B6C:  BTFSC  03.0
0B6D:  INCFSZ 46,W
0B6E:  ADDWF  51,F
0B6F:  MOVF   47,W
0B70:  ADDWF  50,F
0B71:  MOVF   48,W
0B72:  BTFSC  03.0
0B73:  INCFSZ 48,W
0B74:  ADDWF  51,F
0B75:  MOVF   49,W
0B76:  ADDWF  50,W
0B77:  MOVWF  38
0B78:  MOVF   51,W
0B79:  MOVWF  39
0B7A:  MOVF   4A,W
0B7B:  BTFSC  03.0
0B7C:  INCFSZ 4A,W
0B7D:  ADDWF  39,F
....................    } 
....................     
....................    while(TRUE) 
....................    { 
....................       LCD_PUTC("\f"); 
0B7E:  MOVLW  86
0B7F:  BSF    03.6
0B80:  MOVWF  0D
0B81:  MOVLW  00
0B82:  MOVWF  0F
0B83:  BCF    0A.3
0B84:  BCF    03.6
0B85:  CALL   1EF
0B86:  BSF    0A.3
....................       LCD_GOTOXY(1,1); 
0B87:  MOVLW  01
0B88:  MOVWF  5F
0B89:  MOVWF  60
0B8A:  BCF    0A.3
0B8B:  CALL   1B1
0B8C:  BSF    0A.3
....................       LCD_PUTC(" DIGITE CLAVE "); 
0B8D:  MOVLW  87
0B8E:  BSF    03.6
0B8F:  MOVWF  0D
0B90:  MOVLW  00
0B91:  MOVWF  0F
0B92:  BCF    0A.3
0B93:  BCF    03.6
0B94:  CALL   1EF
0B95:  BSF    0A.3
....................       LCD_GOTOXY(1,2); 
0B96:  MOVLW  01
0B97:  MOVWF  5F
0B98:  MOVLW  02
0B99:  MOVWF  60
0B9A:  BCF    0A.3
0B9B:  CALL   1B1
0B9C:  BSF    0A.3
....................       DELAY_MS(100); 
0B9D:  MOVLW  64
0B9E:  MOVWF  5F
0B9F:  BCF    0A.3
0BA0:  CALL   0CF
0BA1:  BSF    0A.3
....................       pedir_clave(); 
0BA2:  BCF    0A.3
0BA3:  CALL   2F2
0BA4:  BSF    0A.3
....................        
....................       if(k=='*') 
0BA5:  MOVF   32,W
0BA6:  SUBLW  2A
0BA7:  BTFSS  03.2
0BA8:  GOTO   3AD
....................          cambio_clave(); 
0BA9:  BCF    0A.3
0BAA:  CALL   39E
0BAB:  BSF    0A.3
0BAC:  GOTO   54A
....................       else 
....................       { 
....................          while((k!='#')) 
0BAD:  MOVF   32,W
0BAE:  SUBLW  23
0BAF:  BTFSC  03.2
0BB0:  GOTO   3BC
....................          { 
....................             TECLADO(); 
0BB1:  BCF    0A.3
0BB2:  CALL   2AA
0BB3:  BSF    0A.3
....................             if(k=='*') 
0BB4:  MOVF   32,W
0BB5:  SUBLW  2A
0BB6:  BTFSS  03.2
0BB7:  GOTO   3BB
....................             cambio_clave(); 
0BB8:  BCF    0A.3
0BB9:  CALL   39E
0BBA:  BSF    0A.3
0BBB:  GOTO   3AD
....................          } 
....................          if(validar_clave()) 
0BBC:  BCF    0A.3
0BBD:  CALL   34B
0BBE:  BSF    0A.3
0BBF:  MOVF   78,F
0BC0:  BTFSC  03.2
0BC1:  GOTO   527
....................          { 
....................             LCD_PUTC("\f"); 
0BC2:  MOVLW  8F
0BC3:  BSF    03.6
0BC4:  MOVWF  0D
0BC5:  MOVLW  00
0BC6:  MOVWF  0F
0BC7:  BCF    0A.3
0BC8:  BCF    03.6
0BC9:  CALL   1EF
0BCA:  BSF    0A.3
....................             LCD_GOTOXY(1,1); 
0BCB:  MOVLW  01
0BCC:  MOVWF  5F
0BCD:  MOVWF  60
0BCE:  BCF    0A.3
0BCF:  CALL   1B1
0BD0:  BSF    0A.3
....................             LCD_PUTC(" CLAVE CORRECTA "); 
0BD1:  MOVLW  90
0BD2:  BSF    03.6
0BD3:  MOVWF  0D
0BD4:  MOVLW  00
0BD5:  MOVWF  0F
0BD6:  BCF    0A.3
0BD7:  BCF    03.6
0BD8:  CALL   1EF
0BD9:  BSF    0A.3
....................             BIT_SET(LED1); 
0BDA:  BSF    07.4
....................             DELAY_MS(200); 
0BDB:  MOVLW  C8
0BDC:  MOVWF  5F
0BDD:  BCF    0A.3
0BDE:  CALL   0CF
0BDF:  BSF    0A.3
....................             BIT_CLEAR(LED1); 
0BE0:  BCF    07.4
....................             while(TRUE) 
....................             { 
....................                LCD_PUTC("\f"); 
0BE1:  MOVLW  99
0BE2:  BSF    03.6
0BE3:  MOVWF  0D
0BE4:  MOVLW  00
0BE5:  MOVWF  0F
0BE6:  BCF    0A.3
0BE7:  BCF    03.6
0BE8:  CALL   1EF
0BE9:  BSF    0A.3
....................                LCD_GOTOXY(1,1); 
0BEA:  MOVLW  01
0BEB:  MOVWF  5F
0BEC:  MOVWF  60
0BED:  BCF    0A.3
0BEE:  CALL   1B1
0BEF:  BSF    0A.3
....................                LCD_PUTC(" INGRESE SU OPC "); 
0BF0:  MOVLW  9A
0BF1:  BSF    03.6
0BF2:  MOVWF  0D
0BF3:  MOVLW  00
0BF4:  MOVWF  0F
0BF5:  BCF    0A.3
0BF6:  BCF    03.6
0BF7:  CALL   1EF
0BF8:  BSF    0A.3
....................                teclado(); 
0BF9:  BCF    0A.3
0BFA:  CALL   2AA
0BFB:  BSF    0A.3
....................                int opc=VAL; 
0BFC:  MOVF   37,W
0BFD:  MOVWF  4F
....................                LCD_GOTOXY(1,2); 
0BFE:  MOVLW  01
0BFF:  MOVWF  5F
0C00:  MOVLW  02
0C01:  MOVWF  60
0C02:  BCF    0A.3
0C03:  CALL   1B1
0C04:  BSF    0A.3
....................                printf(lcd_putc,"%i", opc); 
0C05:  MOVF   4F,W
0C06:  MOVWF  50
0C07:  MOVLW  18
0C08:  MOVWF  51
0C09:  BCF    0A.3
0C0A:  GOTO   508
0C0B:  BSF    0A.3
....................                delay_ms(200); 
0C0C:  MOVLW  C8
0C0D:  MOVWF  5F
0C0E:  BCF    0A.3
0C0F:  CALL   0CF
0C10:  BSF    0A.3
....................                switch(opc) 
0C11:  MOVF   4F,W
0C12:  XORLW  01
0C13:  BTFSC  03.2
0C14:  GOTO   41C
0C15:  XORLW  03
0C16:  BTFSC  03.2
0C17:  GOTO   450
0C18:  XORLW  01
0C19:  BTFSC  03.2
0C1A:  GOTO   4C9
0C1B:  GOTO   525
....................                { 
....................                   case 1: 
....................                      putc(opc); 
0C1C:  MOVF   4F,W
0C1D:  BTFSS  0C.4
0C1E:  GOTO   41D
0C1F:  MOVWF  19
....................                      opc=null; 
0C20:  CLRF   4F
....................  
....................                      enable_interrupts(INT_RDA); 
0C21:  BSF    03.5
0C22:  BSF    0C.5
....................                      enable_interrupts(GLOBAL); 
0C23:  MOVLW  C0
0C24:  BCF    03.5
0C25:  IORWF  0B,F
....................                       
....................                      lcd_putc("\f"); 
0C26:  MOVLW  A3
0C27:  BSF    03.6
0C28:  MOVWF  0D
0C29:  MOVLW  00
0C2A:  MOVWF  0F
0C2B:  BCF    0A.3
0C2C:  BCF    03.6
0C2D:  CALL   1EF
0C2E:  BSF    0A.3
....................                      for(;;) 
....................                      { 
....................                         lcd_gotoxy(1,1); 
0C2F:  MOVLW  01
0C30:  MOVWF  5F
0C31:  MOVWF  60
0C32:  BCF    0A.3
0C33:  CALL   1B1
0C34:  BSF    0A.3
....................                         lcd_putc(" OPCION 1 "); 
0C35:  MOVLW  A4
0C36:  BSF    03.6
0C37:  MOVWF  0D
0C38:  MOVLW  00
0C39:  MOVWF  0F
0C3A:  BCF    0A.3
0C3B:  BCF    03.6
0C3C:  CALL   1EF
0C3D:  BSF    0A.3
....................                         lcd_gotoxy(1,2); 
0C3E:  MOVLW  01
0C3F:  MOVWF  5F
0C40:  MOVLW  02
0C41:  MOVWF  60
0C42:  BCF    0A.3
0C43:  CALL   1B1
0C44:  BSF    0A.3
0C45:  GOTO   42F
....................                         //printf(lcd_putc,"Recibido= %1D",valor); 
....................                      } 
....................                      /*for(valor=0;valor<=10;valor++) 
....................                      { 
....................                         putc(valor);  
....................                         printf(lcd_putc,"\fEnviando= %1D",valor); 
....................                         delay_ms(200); 
....................                      }*/ 
....................                      lcd_putc("\f"); 
0C46:  MOVLW  AA
0C47:  BSF    03.6
0C48:  MOVWF  0D
0C49:  MOVLW  00
0C4A:  MOVWF  0F
0C4B:  BCF    0A.3
0C4C:  BCF    03.6
0C4D:  CALL   1EF
0C4E:  BSF    0A.3
....................                      break; 
0C4F:  GOTO   525
....................                   case 2: 
....................                      putc(opc); 
0C50:  MOVF   4F,W
0C51:  BTFSS  0C.4
0C52:  GOTO   451
0C53:  MOVWF  19
....................                      opc=null; 
0C54:  CLRF   4F
....................                       
....................                      while(opc==null) 
0C55:  MOVF   4F,F
0C56:  BTFSS  03.2
0C57:  GOTO   4BF
....................                      { 
....................                         tomar_temp(); 
0C58:  CALL   000
....................                         lcd_gotoxy(1,1); 
0C59:  MOVLW  01
0C5A:  MOVWF  5F
0C5B:  MOVWF  60
0C5C:  BCF    0A.3
0C5D:  CALL   1B1
0C5E:  BSF    0A.3
....................                         lcd_putc("\fTEMPERATURA"); 
0C5F:  MOVLW  AB
0C60:  BSF    03.6
0C61:  MOVWF  0D
0C62:  MOVLW  00
0C63:  MOVWF  0F
0C64:  BCF    0A.3
0C65:  BCF    03.6
0C66:  CALL   1EF
0C67:  BSF    0A.3
....................                         lcd_gotoxy(2,2); 
0C68:  MOVLW  02
0C69:  MOVWF  5F
0C6A:  MOVWF  60
0C6B:  BCF    0A.3
0C6C:  CALL   1B1
0C6D:  BSF    0A.3
....................                         printf(lcd_putc,"C= %f    ",tem); 
0C6E:  MOVLW  43
0C6F:  MOVWF  5E
0C70:  BCF    0A.3
0C71:  CALL   1C3
0C72:  BSF    0A.3
0C73:  MOVLW  3D
0C74:  MOVWF  5E
0C75:  BCF    0A.3
0C76:  CALL   1C3
0C77:  BSF    0A.3
0C78:  MOVLW  20
0C79:  MOVWF  5E
0C7A:  BCF    0A.3
0C7B:  CALL   1C3
0C7C:  BSF    0A.3
0C7D:  MOVLW  89
0C7E:  MOVWF  04
0C7F:  MOVF   40,W
0C80:  MOVWF  53
0C81:  MOVF   3F,W
0C82:  MOVWF  52
0C83:  MOVF   3E,W
0C84:  MOVWF  51
0C85:  MOVF   3D,W
0C86:  MOVWF  50
0C87:  MOVLW  02
0C88:  MOVWF  54
0C89:  BCF    0A.3
0C8A:  CALL   642
0C8B:  BSF    0A.3
0C8C:  MOVLW  B4
0C8D:  BSF    03.6
0C8E:  MOVWF  0D
0C8F:  MOVLW  00
0C90:  MOVWF  0F
0C91:  BSF    03.0
0C92:  MOVLW  04
0C93:  BCF    03.6
0C94:  MOVWF  50
0C95:  BCF    0A.3
0C96:  CALL   722
0C97:  BSF    0A.3
....................                         //tem=roundf(tem * 100) / 100; 
....................                         tem=tem*100; 
0C98:  MOVF   40,W
0C99:  MOVWF  60
0C9A:  MOVF   3F,W
0C9B:  MOVWF  5F
0C9C:  MOVF   3E,W
0C9D:  MOVWF  5E
0C9E:  MOVF   3D,W
0C9F:  MOVWF  5D
0CA0:  CLRF   64
0CA1:  CLRF   63
0CA2:  MOVLW  48
0CA3:  MOVWF  62
0CA4:  MOVLW  85
0CA5:  MOVWF  61
0CA6:  BCF    0A.3
0CA7:  CALL   57E
0CA8:  BSF    0A.3
0CA9:  MOVF   7A,W
0CAA:  MOVWF  40
0CAB:  MOVF   79,W
0CAC:  MOVWF  3F
0CAD:  MOVF   78,W
0CAE:  MOVWF  3E
0CAF:  MOVF   77,W
0CB0:  MOVWF  3D
....................                         putc(tem); 
0CB1:  MOVF   3D,W
0CB2:  BTFSS  0C.4
0CB3:  GOTO   4B2
0CB4:  MOVWF  19
....................                         teclado(); 
0CB5:  BCF    0A.3
0CB6:  CALL   2AA
0CB7:  BSF    0A.3
....................                         opc=VAL; 
0CB8:  MOVF   37,W
0CB9:  MOVWF  4F
....................                         putc(opc); 
0CBA:  MOVF   4F,W
0CBB:  BTFSS  0C.4
0CBC:  GOTO   4BB
0CBD:  MOVWF  19
0CBE:  GOTO   455
....................                      } 
....................                      lcd_putc("\f"); 
0CBF:  MOVLW  B7
0CC0:  BSF    03.6
0CC1:  MOVWF  0D
0CC2:  MOVLW  00
0CC3:  MOVWF  0F
0CC4:  BCF    0A.3
0CC5:  BCF    03.6
0CC6:  CALL   1EF
0CC7:  BSF    0A.3
....................                      break; 
0CC8:  GOTO   525
....................  
....................                   case 3: 
....................                      putc(opc); 
0CC9:  MOVF   4F,W
0CCA:  BTFSS  0C.4
0CCB:  GOTO   4CA
0CCC:  MOVWF  19
....................                      opc=null; 
0CCD:  CLRF   4F
....................                       
....................                      while(opc==null) 
0CCE:  MOVF   4F,F
0CCF:  BTFSS  03.2
0CD0:  GOTO   51C
....................                      { 
....................                         tomar_temp(); 
0CD1:  CALL   000
....................                         i=0; 
0CD2:  CLRF   41
....................                         lcd_gotoxy(1,1); 
0CD3:  MOVLW  01
0CD4:  MOVWF  5F
0CD5:  MOVWF  60
0CD6:  BCF    0A.3
0CD7:  CALL   1B1
0CD8:  BSF    0A.3
....................                         lcd_putc("\fTEMPERATURA"); 
0CD9:  MOVLW  B8
0CDA:  BSF    03.6
0CDB:  MOVWF  0D
0CDC:  MOVLW  00
0CDD:  MOVWF  0F
0CDE:  BCF    0A.3
0CDF:  BCF    03.6
0CE0:  CALL   1EF
0CE1:  BSF    0A.3
....................                         lcd_gotoxy(2,2); 
0CE2:  MOVLW  02
0CE3:  MOVWF  5F
0CE4:  MOVWF  60
0CE5:  BCF    0A.3
0CE6:  CALL   1B1
0CE7:  BSF    0A.3
....................                         printf(lcd_putc,"C= %f    ",tem); 
0CE8:  MOVLW  43
0CE9:  MOVWF  5E
0CEA:  BCF    0A.3
0CEB:  CALL   1C3
0CEC:  BSF    0A.3
0CED:  MOVLW  3D
0CEE:  MOVWF  5E
0CEF:  BCF    0A.3
0CF0:  CALL   1C3
0CF1:  BSF    0A.3
0CF2:  MOVLW  20
0CF3:  MOVWF  5E
0CF4:  BCF    0A.3
0CF5:  CALL   1C3
0CF6:  BSF    0A.3
0CF7:  MOVLW  89
0CF8:  MOVWF  04
0CF9:  MOVF   40,W
0CFA:  MOVWF  53
0CFB:  MOVF   3F,W
0CFC:  MOVWF  52
0CFD:  MOVF   3E,W
0CFE:  MOVWF  51
0CFF:  MOVF   3D,W
0D00:  MOVWF  50
0D01:  MOVLW  02
0D02:  MOVWF  54
0D03:  BCF    0A.3
0D04:  CALL   642
0D05:  BSF    0A.3
0D06:  MOVLW  C1
0D07:  BSF    03.6
0D08:  MOVWF  0D
0D09:  MOVLW  00
0D0A:  MOVWF  0F
0D0B:  BSF    03.0
0D0C:  MOVLW  04
0D0D:  BCF    03.6
0D0E:  MOVWF  50
0D0F:  BCF    0A.3
0D10:  CALL   722
0D11:  BSF    0A.3
....................                         putc(tem); 
0D12:  MOVF   3D,W
0D13:  BTFSS  0C.4
0D14:  GOTO   513
0D15:  MOVWF  19
....................                         delay_ms(200); 
0D16:  MOVLW  C8
0D17:  MOVWF  5F
0D18:  BCF    0A.3
0D19:  CALL   0CF
0D1A:  BSF    0A.3
0D1B:  GOTO   4CE
....................                      } 
....................                      lcd_putc("\f"); 
0D1C:  MOVLW  C4
0D1D:  BSF    03.6
0D1E:  MOVWF  0D
0D1F:  MOVLW  00
0D20:  MOVWF  0F
0D21:  BCF    0A.3
0D22:  BCF    03.6
0D23:  CALL   1EF
0D24:  BSF    0A.3
....................                      break; 
....................                } 
0D25:  GOTO   3E1
....................             } 
....................          } 
0D26:  GOTO   54A
....................          else 
....................          { 
....................             LCD_PUTC("\f"); 
0D27:  MOVLW  C5
0D28:  BSF    03.6
0D29:  MOVWF  0D
0D2A:  MOVLW  00
0D2B:  MOVWF  0F
0D2C:  BCF    0A.3
0D2D:  BCF    03.6
0D2E:  CALL   1EF
0D2F:  BSF    0A.3
....................             LCD_GOTOXY(1,1); 
0D30:  MOVLW  01
0D31:  MOVWF  5F
0D32:  MOVWF  60
0D33:  BCF    0A.3
0D34:  CALL   1B1
0D35:  BSF    0A.3
....................             LCD_PUTC(" CLAVE INVALIDA "); 
0D36:  MOVLW  C6
0D37:  BSF    03.6
0D38:  MOVWF  0D
0D39:  MOVLW  00
0D3A:  MOVWF  0F
0D3B:  BCF    0A.3
0D3C:  BCF    03.6
0D3D:  CALL   1EF
0D3E:  BSF    0A.3
....................             BIT_SET(LED2); 
0D3F:  BSF    07.5
....................             DELAY_MS(500); 
0D40:  MOVLW  02
0D41:  MOVWF  50
0D42:  MOVLW  FA
0D43:  MOVWF  5F
0D44:  BCF    0A.3
0D45:  CALL   0CF
0D46:  BSF    0A.3
0D47:  DECFSZ 50,F
0D48:  GOTO   542
....................             BIT_CLEAR(LED2); 
0D49:  BCF    07.5
....................          } 
....................       } 
0D4A:  GOTO   37E
....................    } 
.................... } 
0D4B:  SLEEP

Configuration Fuses:
   Word  1: 2CF1   XT NOWDT NOPUT MCLR NOPROTECT NOCPD NOBROWNOUT IESO FCMEN NOLVP NODEBUG
   Word  2: 3FFF   BORV40 NOWRT
